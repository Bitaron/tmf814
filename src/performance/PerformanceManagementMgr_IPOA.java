package performance;


/**
* performance/PerformanceManagementMgr_IPOA.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from performance.idl
* Wednesday, June 15, 2016 7:24:40 PM COT
*/


/**
   * <p>The PerformanceManagementMgr_I is used to gain access to operations
   * which deal with performance Monitoring</p>
   *
   * <p>A handle to an instance of this interface is gained via the
   * emsSession::EmsSession_I::getManager() operation in 
   * managerInterface when the managerName "PerformanceManagement" is used.</p>
   **/
public abstract class PerformanceManagementMgr_IPOA extends org.omg.PortableServer.Servant
 implements performance.PerformanceManagementMgr_IOperations, org.omg.CORBA.portable.InvokeHandler
{

  // Constructors

  private static java.util.Hashtable _methods = new java.util.Hashtable ();
  static
  {
    _methods.put ("getMEPMcapabilities", new java.lang.Integer (0));
    _methods.put ("disablePMData", new java.lang.Integer (1));
    _methods.put ("enablePMData", new java.lang.Integer (2));
    _methods.put ("clearPMData", new java.lang.Integer (3));
    _methods.put ("getHoldingTime", new java.lang.Integer (4));
    _methods.put ("getTCATPParameter", new java.lang.Integer (5));
    _methods.put ("getHistoryPMData", new java.lang.Integer (6));
    _methods.put ("getAllCurrentPMData", new java.lang.Integer (7));
    _methods.put ("setTCATPParameter", new java.lang.Integer (8));
    _methods.put ("enableTCA", new java.lang.Integer (9));
    _methods.put ("disableTCA", new java.lang.Integer (10));
    _methods.put ("getProfileAssociatedTPs", new java.lang.Integer (11));
    _methods.put ("createTCAParameterProfile", new java.lang.Integer (12));
    _methods.put ("deleteTCAParameterProfile", new java.lang.Integer (13));
    _methods.put ("getTCAParameterProfile", new java.lang.Integer (14));
    _methods.put ("setTCAParameterProfile", new java.lang.Integer (15));
    _methods.put ("getAllTCAParameterProfileNames", new java.lang.Integer (16));
    _methods.put ("getTPHistoryPMData", new java.lang.Integer (17));
    _methods.put ("getAllPMPs", new java.lang.Integer (18));
    _methods.put ("getAllPMPNames", new java.lang.Integer (19));
    _methods.put ("setTCAParameterProfilePointer", new java.lang.Integer (20));
    _methods.put ("getAllTCAParameterProfiles", new java.lang.Integer (21));
    _methods.put ("setNativeEMSName", new java.lang.Integer (22));
    _methods.put ("setUserLabel", new java.lang.Integer (23));
    _methods.put ("setOwner", new java.lang.Integer (24));
    _methods.put ("getCapabilities", new java.lang.Integer (25));
    _methods.put ("setAdditionalInfo", new java.lang.Integer (26));
  }

  public org.omg.CORBA.portable.OutputStream _invoke (String $method,
                                org.omg.CORBA.portable.InputStream in,
                                org.omg.CORBA.portable.ResponseHandler $rh)
  {
    org.omg.CORBA.portable.OutputStream out = null;
    java.lang.Integer __method = (java.lang.Integer)_methods.get ($method);
    if (__method == null)
      throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);

    switch (__method.intValue ())
    {

  /**
     * <p>This operation allows the NMS to request, from the EMS, the set
     * of PM parameters supported by a particular ME at a specific layer.<p>
     *
     * <br>globaldefs::NamingAttributes_T meName: Gives the name of the managed 
     * element
     * <br>transmissionParameters::LayerRate layerRate: Gives the layerRate 
     * considered.
     * <br>PMParameterList pmParameterList This out parameter contains the set 
     * of PM parameters that are supported by the ME referred to.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when meName does not reference an 
     *  managedElement object or layerRate contains undefined rates<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when meName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     * lost<br>
     * <br>
     **/
       case 0:  // performance/PerformanceManagementMgr_I/getMEPMcapabilities
       {
         try {
           globaldefs.NameAndStringValue_T meName[] = globaldefs.NamingAttributes_THelper.read (in);
           short layerRate = transmissionParameters.LayerRate_THelper.read (in);
           performance.PMParameterList_THolder pmParameterList = new performance.PMParameterList_THolder ();
           this.getMEPMcapabilities (meName, layerRate, pmParameterList);
           out = $rh.createReply();
           performance.PMParameterList_THelper.write (out, pmParameterList.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation instructs the EMS to turn off PM data collection for a 
     * list of measurement points. Within the request for each measurement point, 
     * one may specify the granularity (15min, 24h, NA, etc.) and location 
     * (nearEnd and/or farEnd and/or bidirectional) for the PM parameters that are 
     * to be deactivated.<p>
     * <p>Disabling is done on a best-effort basis. If PM could not be disabled
     * for a subset of cases in
     * the PMTPSelectList a  list identifying this subset is returned.</p>
     * <p>PM collection stops immediately, i.e., before the completion of the 
     * current monitoring period. This may lead to incomplete 
     * collection periods. If PM collection was never started for this TP, the 
     * operation is considered successful.</p>
     *
     * <br>PMTPSelectList_T pmTPSelectList: This struct contains the relevant 
     * data for the disablePMData request. It must not be empty.
     * <br>PMTPSelectList_T failedTPSelectList: List of points which were not 
     * completely disabled. An empty list indicates that the total request was 
     * successful.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised if pmTPSelectList is empty or contains invalid 
     *  data<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
       case 1:  // performance/PerformanceManagementMgr_I/disablePMData
       {
         try {
           performance.PMTPSelect_T pmTPSelectList[] = performance.PMTPSelectList_THelper.read (in);
           performance.PMTPSelectList_THolder failedTPSelectList = new performance.PMTPSelectList_THolder ();
           this.disablePMData (pmTPSelectList, failedTPSelectList);
           out = $rh.createReply();
           performance.PMTPSelectList_THelper.write (out, failedTPSelectList.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation instructs the EMS to enable (turn on) PM data collection
     * for a list of measurement points. Within the request for each measurement 
     * point, one may specify the granularity (15min, 24h, NA, etc.) and location 
     * (nearEnd and/or farEnd and/or bidirectional) for the PM parameters that  
     * are to be activated.</p>
     *
     * <p>Enabling is done on best-effort basis. If PM could not be enabled
     * for a subset of cases in the pmTPSelectList, a list identifying this  
     * subset is returned.</p>
     *
     * <p>PM data collection starts immediately, i.e., before the completion of 
     * the current hour monitoring period. This may lead to  
     * incomplete collection periods. If PM collection was already on for a TP,
     * the operation is considered successful.</p>
     *
     * <br>PMTPSelectList_T pmTPSelectList: This struct contains the relevant 
     * data for the enablePMData request. This must not be empty.
     * <br>PMTPSelectList_T failedTPSelectList: List of points which were not 
     * completely enabled. An empty list indicates that the total request was 
     * successful.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised if pmTPSelectList is empty or contains invalid 
     *  data<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_CAPACITY_EXCEEDED - Raised when the maximum number of simultaneously 
     *  enabled monitoring points is exceeded<br>
     * <br>
     **/
       case 2:  // performance/PerformanceManagementMgr_I/enablePMData
       {
         try {
           performance.PMTPSelect_T pmTPSelectList[] = performance.PMTPSelectList_THelper.read (in);
           performance.PMTPSelectList_THolder failedTPSelectList = new performance.PMTPSelectList_THolder ();
           this.enablePMData (pmTPSelectList, failedTPSelectList);
           out = $rh.createReply();
           performance.PMTPSelectList_THelper.write (out, failedTPSelectList.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation instructs the EMS to clear (reset) the PM registers
     * for a list of measurement points. Within the request for each measurement 
     * point, one may specify the granularity (15min, 24h, NA, etc.) and location 
     * (nearEnd and/or farEnd and/or bidirectional) for the PM registers that are 
     * to be reset.</p>
     *
     * <p>Clearing PM gauge minimum, maximum, and average registers means to reset 
     * them to the current measurement; for the actual gauge measurement, it has 
     * no effect. This is not considered a failure case.</p>
     *
     * <p>Clearing PM registers is done on best-effort basis. If registers could 
     * not be completely cleared for a subset of cases in the pmTPSelectList, 
     * a list identifying this subset is returned.</p>
     *
     * <br>PMTPSelectList_T pmTPSelectList: This struct contains the relevant 
     * data for the clearPMData request. It must not be empty.
     * <br>PMTPSelectList_T failedTPSelectList: List of points for which PM 
     * registers were not completely cleared. An empty list indicates that the 
     * total request was successful.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS is unable to support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised if pmTPSelectList is empty or contains invalid 
     *  data<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost
     * <br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     **/
       case 3:  // performance/PerformanceManagementMgr_I/clearPMData
       {
         try {
           performance.PMTPSelect_T pmTPSelectList[] = performance.PMTPSelectList_THelper.read (in);
           performance.PMTPSelectList_THolder failedTPSelectList = new performance.PMTPSelectList_THolder ();
           this.clearPMData (pmTPSelectList, failedTPSelectList);
           out = $rh.createReply();
           performance.PMTPSelectList_THelper.write (out, failedTPSelectList.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>The EMS is requested to inform the NMS about how many hours PM data 
     * records (24h/15min) are held in the EMS. This is the minimum time. If EMS 
     * does not store PM data it is the time supported in the NE (minimum time of 
     * all managed NEs).</p>
     *
     * <br>HoldingTime holdingTime: This out parameter contains the time period 
     * in hours within which 24h PM data records and 15min PM data records may be 
     * retrieved.
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS is unable to support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_NE_COMM_LOSS - Raised if communication is down to an NE and holding 
     *  time cannot be retrieved
     * <br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     **/
       case 4:  // performance/PerformanceManagementMgr_I/getHoldingTime
       {
         try {
           performance.HoldingTime_THolder holdingTime = new performance.HoldingTime_THolder ();
           this.getHoldingTime (holdingTime);
           out = $rh.createReply();
           performance.HoldingTime_THelper.write (out, holdingTime.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /** 
     * <p>The purpose of this operation is to retrieve the values of PM thresholds 
     * on a TP/layerRate measurement point. The operation is best-effort. Results 
     * are returned in the out parameter of this operation. The operation can be 
     * applied to a PTP, an FTP or CTP. The NMS requests the TCA parameters for 
     * the particular TP and granularity specified.</p>
     *
     * <br>globaldefs::NamingAttributes_T tpName: Identification of the TP for 
     * which the values of the TCA parameters are to be retrieved. The termination 
     * point name must be explicit (a generic endpoint specification may not be 
     * used in this case).See <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further details on TP naming.
     * <br>transmissionParameters::LayerRate_T layerRate: LayerRate for which 
     * the values of the TCA parameters are to be retrieved.
     * <br><b>in</b>  Granularity_T granularity: Granularity for which the TCA 
     * parameters are to be retrieved
     * <br><b>out</b> TCAParameters_T tcaParameter: Result of the operation
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when tpName does not reference a 
     *  terminationPoint object or layerRate contains an undefined rate or 
     *  Granularity contains an undefined value<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references an object which 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
       case 5:  // performance/PerformanceManagementMgr_I/getTCATPParameter
       {
         try {
           globaldefs.NameAndStringValue_T tpName[] = globaldefs.NamingAttributes_THelper.read (in);
           short layerRate = transmissionParameters.LayerRate_THelper.read (in);
           String granularity = performance.Granularity_THelper.read (in);
           performance.TCAParameters_THolder tcaParameter = new performance.TCAParameters_THolder ();
           this.getTCATPParameter (tpName, layerRate, granularity, tcaParameter);
           out = $rh.createReply();
           performance.TCAParameters_THelper.write (out, tcaParameter.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation instructs the EMS to store history PM data into a file,
     * and to send that file by FTP (File Transfer Protocol)
     * to the destination as specified in the request. Within the 
     * request a list of TP/layerRate measurement points and a time frame are 
     * specified. For each measurement point, the granularity (15min, 24h, NA, 
     * etc) and location (nearEnd and/or farEnd and/or bidirectional) may be 
     * specified. A filtered set (scoped by the input parameter pmParameters) of 
     * PM parameters collected for a particular TP/layerRate measurement point for 
     * the granularity, location and time window specified is made available.</p>
     *
     * <p>Measurement intervals and the given time frame are considered as half 
     * open intervals to the right, i.e. startTime <= t < endTime.</p>
     *
     * <p>A particular historic measurement interval (of duration
     * 15 min resp. 24 h) is defined to be covered by the specified time
     * frame if there is a non empty intersection between the measurement
     * interval and the given time frame, i.e.
     * <br>endTime[PM record] > startTime[request parameter] AND<br>
     * <br>startTime[PM record] &lt; endTime[request parameter]<br>
     * PM data are returned for all covered measurement intervals.</p>
     *
     * <p>For records partly included in the time frame specified, PM data will be 
     * returned. In case a history bin has incomplete PM measurement data (for 
     * instance because PM data collection was disabled for some time period(s) 
     * within the bin's time span), the particular measurement period will be 
     * marked as incomplete.</p>
     *
     * <p>If the forceUpload parameter is true,
     * the EMS is to upload the data for all the specified collection periods 
     * (provided they do exist in the MEs) and provide the entire PM data 
     * requested. If the forceUpload parameter is false,
     * measurement intervals within the specified time frame for which
     * PM data has been collected in the ME but not yet uploaded to the
     * EMS will be included in the PM file with status "Unavailable",
     * however without valid PM data.  </p>
     *
     * <p>Performance Monitoring Data transfer normally involves huge amounts of 
     * data. The capability to send PM data to a controlled destination other than 
     * the NMS allows for flexibility 
     * in the choice of the PM data file format, the particular file transfer 
     * protocol (including the possibility to apply data compression techniques) 
     * and the destination machine so as to make optimal use of the available data 
     * network capacity. The file transfer protocol to transfer PM data is the FTP 
     * protocol.</p>
     *
     * <p>This operation is asynchrounous and is not required to wait until the PM 
     * data is extracted or until the FTP transfer is over before it returns.
     * Notifications can be generated to inform the NMS of the progress of the 
     * transfer.  See
     * <a href=../../../supportingDocumentation/SD1-26_OMGServicesUsage.pdf >SD1-26 Notification 
     * Service and Telecoms Log Service Usage</a> for details.</p>
     *
     * <p>Performance monitoring data on multiple TPs of multiple MEs is 
     * transferred in one data file. This PM data file has the following format:
     * <a href=../../../supportingDocumentation/SD1-30_PMFileFormat.pdf > SD1-30 PM File Format 
     * Definition</a>.</p>
     *
     * <br>Destination_T destination: The destination to which the
     * Performance Monitoring Data file is to be send.
     * <br>String userName: necessary for file transfer with FTP
     * <br>String password: necessary for file transfer with FTP
     * <br>PMTPSelectList_T pmTPSelectList. This parameter specifies which 
     * history PM data to return. If pmTPSelectList is empty, PM data for all 
     * monitored TPs of all MEs managed by the EMS (all layer rates, all 
     * granularities) are stored in the file.
     * <br>PMParameterNameList_T pmParameters. This parameter specifies which PM 
     * parameters within the scope of the pmTPSelectList shall be contained in the 
     * file. An empty list means to store all supported parameters.
     * The returned parameters are best effort, i.e. among the parameters 
     * specified only the subset of supported parameters will be stored.
     * <br>globaldefs::Time_T startTime: Specifies the start of the time window 
     * for collection (included).
     * <br>globaldefs::Time_T endTime: Specifies the end of the time window for 
     * collection (excluded).
     * <br>boolean forceUpload: Specifies if the EMS must upload all available 
     * PM data requested from the MEs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is not well 
     *  formed<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to the NE is down<br>
     * <br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     **/
       case 6:  // performance/PerformanceManagementMgr_I/getHistoryPMData
       {
         try {
           String destination = performance.Destination_THelper.read (in);
           String userName = in.read_string ();
           String password = in.read_string ();
           performance.PMTPSelect_T pmTPSelectList[] = performance.PMTPSelectList_THelper.read (in);
           String pmParameters[] = performance.PMParameterNameList_THelper.read (in);
           String startTime = globaldefs.Time_THelper.read (in);
           String endTime = globaldefs.Time_THelper.read (in);
           boolean forceUpload = in.read_boolean ();
           this.getHistoryPMData (destination, userName, password, pmTPSelectList, pmParameters, startTime, endTime, forceUpload);
           out = $rh.createReply();
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This allows an NMS to request a filtered set (scoped by the input 
     * parameter pmParameters) of the current PM data
     * for a list of TP measurement points. Within the request for each 
     * measurement point, granularity (15min, 24h, NA, etc.) and location (nearEnd 
     * and/or farEnd and/or bidirectional) may be specified. The operation mode is 
     * best effort.</p>
     *
     * <p>Current data will generally be marked as incomplete, as the 
     * current bin is not completed.
     * If no PM data are available as specified, an empty list is returned.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>PMTPSelectList_T pmTPSelectList: list of measurement points for which
     * to get the PM data.
     * <br>PMParameterNameList_T pmParameters: specifies which PM parameters 
     * within the scope of the pmTPSelectList shall be returned.
     * An empty list means to return all supported parameters.
     * The returned parameters are best effort, i.e. among the parameters 
     * specified only the subset of supported parameters will be returned.
     * <br>unsigned long how_many: maximum number of PMData to return in the 
     * first batch.
     * <br>PMDataList_T pmDataList: first batch of PMData returned.
     * <br>PMDataIterator_I pmIt: iterator returned to access the remaining 
     * PMData.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when pmTPSelectList is empty or contains 
     *  invalid data<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to the Managed Element 
     *  is lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 7:  // performance/PerformanceManagementMgr_I/getAllCurrentPMData
       {
         try {
           performance.PMTPSelect_T pmTPSelectList[] = performance.PMTPSelectList_THelper.read (in);
           String pmParameters[] = performance.PMParameterNameList_THelper.read (in);
           int how_many = in.read_ulong ();
           performance.PMDataList_THolder pmDataList = new performance.PMDataList_THolder ();
           performance.PMDataIterator_IHolder pmIt = new performance.PMDataIterator_IHolder ();
           this.getAllCurrentPMData (pmTPSelectList, pmParameters, how_many, pmDataList, pmIt);
           out = $rh.createReply();
           performance.PMDataList_THelper.write (out, pmDataList.value);
           performance.PMDataIterator_IHelper.write (out, pmIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>The purpose of this operation is to modify the values of TCA thresholds 
     * on a TP-layerRate measurement point. It can be applied to a PTP, an FTP or 
     * CTP. For a threshold, a low and high mark may be specified. The NMS 
     * specifies the TP and layerRate, the granularity, and the value(s) of one or 
     * more TCA threshold(s) to be modified.The operation mode is best-effort.
     * If no TCA value is set, a default value will be active.</p>
     * 
     * <br><b>in</b> globaldefs::NamingAttributes_T tpName:
     * Identification of the TP for which the values of one or more TCA parameters 
     * are set. The termination point name must be explicit (a generic endpoint 
     * specification may not be used in this case).
     * See <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br><b>inout</b> TCAParameters tcaParameter: The list of TCA
     * ids and corresponding values to be applied to a specific 
     * layer rate are specified by this parameter.
     * The settings that are actually applied are returned in this parameter.<br>
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised if tpName does not reference a 
     *  terminationPoint object or at least one field of tcaParameters is not 
     *  valid.<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 8:  // performance/PerformanceManagementMgr_I/setTCATPParameter
       {
         try {
           globaldefs.NameAndStringValue_T tpName[] = globaldefs.NamingAttributes_THelper.read (in);
           performance.TCAParameters_THolder tcaParameters = new performance.TCAParameters_THolder ();
           tcaParameters.value = performance.TCAParameters_THelper.read (in);
           this.setTCATPParameter (tpName, tcaParameters);
           out = $rh.createReply();
           performance.TCAParameters_THelper.write (out, tcaParameters.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation will enable TCA generation on a list of TPs and/or MEs
     * at the ME level.</p> 
     *
     * <br>PMTPSelectList_T pmTPSelectList: This struct contains the relevant 
     * data for the enableTCA request. This must not be empty.
     * <br>PMTPSelectList_T failedTPSelectList: List of points which were not 
     * completely enabled.An empty list indicates that the total request was 
     * successful.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if this operation is not supported<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised if pmTPSelectList is empty or contains invalid 
     *  data<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised if the EMS is unable to enable TCA for the
     *  specified TPs (pmTPSelectList), i.e. no TPs were enabled.<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     */
       case 9:  // performance/PerformanceManagementMgr_I/enableTCA
       {
         try {
           performance.PMTPSelect_T pmTPSelectList[] = performance.PMTPSelectList_THelper.read (in);
           performance.PMTPSelectList_THolder failedTPSelectList = new performance.PMTPSelectList_THolder ();
           this.enableTCA (pmTPSelectList, failedTPSelectList);
           out = $rh.createReply();
           performance.PMTPSelectList_THelper.write (out, failedTPSelectList.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation will disable TCA generation on a list of TPs and/or MEs
     * at the ME level.</p>
     *
     * <br>PMTPSelectList_T pmTPSelectList: This struct contains the relevant 
     * data for the enableTCA request. This must not be empty.
     * <br>PMTPSelectList_T failedTPSelectList: List of points which were not 
     * completely disabled. An empty list indicates that the total request was 
     * successful.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if this operation is not supported<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised if pmTPSelectList is empty or contains invalid 
     *  data<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised if the EMS is unable to disable TCA for the
     *  specified TPs (pmTPSelectList), i.e. no TPs were disabled<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     */
       case 10:  // performance/PerformanceManagementMgr_I/disableTCA
       {
         try {
           performance.PMTPSelect_T pmTPSelectList[] = performance.PMTPSelectList_THelper.read (in);
           performance.PMTPSelectList_THolder failedTPSelectList = new performance.PMTPSelectList_THolder ();
           this.disableTCA (pmTPSelectList, failedTPSelectList);
           out = $rh.createReply();
           performance.PMTPSelectList_THelper.write (out, failedTPSelectList.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation gets the set of TPs that are associated with a TCA
     * Parameter Profile.<p>
     *
     * <br><b>in</b> globaldefs::NamingAttributes_T profileName: gives the name 
     * of the profile.
     * <br><b>in</b> unsigned long how_many: maximum number of tpNames to return 
     * in the first batch.
     * <br><b>out</b> globaldefs::NamingAttributesList_T tpNames: provides set 
     * of TPs associated with the profile provided.
     * <br><b>out</b> globaldefs::NamingAttributesIterator_I nameIt: Iterator to
     * retrieve the remaining TP names.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when input parameter are syntactical 
     *  incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when profileName references an object which
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managed element is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 11:  // performance/PerformanceManagementMgr_I/getProfileAssociatedTPs
       {
         try {
           globaldefs.NameAndStringValue_T profileName[] = globaldefs.NamingAttributes_THelper.read (in);
           int how_many = in.read_ulong ();
           globaldefs.NamingAttributesList_THolder tpNames = new globaldefs.NamingAttributesList_THolder ();
           globaldefs.NamingAttributesIterator_IHolder nameIt = new globaldefs.NamingAttributesIterator_IHolder ();
           this.getProfileAssociatedTPs (profileName, how_many, tpNames, nameIt);
           out = $rh.createReply();
           globaldefs.NamingAttributesList_THelper.write (out, tpNames.value);
           globaldefs.NamingAttributesIterator_IHelper.write (out, nameIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation creates a new TCA Parameter Profile.<p>
     *
     * <br><b>in</b> globaldefs::NamingAttributes_T managedElementName: ME under
     *  which the profile is to be created.
     * <br><b>in</b> transmissionParameters::LayerRate_T layerRate: defines the
     * <a href=../../../supportingDocumentation/SD1-17_LayerRates.pdf >SD1-17 layer rate</a> of the 
     * profile to be created.
     * <br><b>in</b> string userLabel: contains the NMS defined name of the 
     * profile to be created.
     * <br><b>in</b> boolean forceUniqueness: if set to TRUE the EMS has to 
     * check if the provided user label is unique in the network element domain.
     * <br><b>in</b> string owner: A label of the owner of the Profile. This is 
     * an optional parameter.
     * <br><b>in</b> globaldefs::NVSList_T additionalInfo: Some additional
     * information may be specified by the NMS.
     * <br><b>in</b> TCAParameterList_T listOfTCAParameter: contains sets of
     * threshold values.
     * <br><b>out</b> TCAParameterProfile_T tcaParameterProfile: EMS returns the
     * new profile to the NMS.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when input parameter are syntactical 
     *  incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when specified managedElement does not 
     *  exist<br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is
     *  not met<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managed element is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 12:  // performance/PerformanceManagementMgr_I/createTCAParameterProfile
       {
         try {
           globaldefs.NameAndStringValue_T managedElementName[] = globaldefs.NamingAttributes_THelper.read (in);
           short layerRate = transmissionParameters.LayerRate_THelper.read (in);
           String userLabel = in.read_string ();
           boolean forceUniqueness = in.read_boolean ();
           String owner = in.read_string ();
           globaldefs.NameAndStringValue_T additionalInfo[] = globaldefs.NVSList_THelper.read (in);
           performance.TCAParameter_T listOfTCAParameter[] = performance.TCAParameterList_THelper.read (in);
           performance.TCAParameterProfile_THolder tcaParameterProfile = new performance.TCAParameterProfile_THolder ();
           this.createTCAParameterProfile (managedElementName, layerRate, userLabel, forceUniqueness, owner, additionalInfo, listOfTCAParameter, tcaParameterProfile);
           out = $rh.createReply();
           performance.TCAParameterProfile_THelper.write (out, tcaParameterProfile.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation deletes a TCA Parameter Profile.<p>
     *
     * <br><b>in</b> globaldefs::NamingAttributes_T tcaParameterProfileName: 
     * name of the profile to be deleted.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when input parameter are syntactical 
     *  incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when specified Profile does not exist<br>
     * EXCPT_OBJECT_IN_USE - Raised when Profile is still assigned to at least
     *  one TP<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managed element is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 13:  // performance/PerformanceManagementMgr_I/deleteTCAParameterProfile
       {
         try {
           globaldefs.NameAndStringValue_T tcaParameterProfileName[] = globaldefs.NamingAttributes_THelper.read (in);
           this.deleteTCAParameterProfile (tcaParameterProfileName);
           out = $rh.createReply();
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation gets all threshold values of a TCA Parameter Profile.<p>
     *
     * <br><b>in</b> globaldefs::NamingAttributes_T tcaParameterProfileName: 
     * name of the profile to be retrieved.
     * <br><b>out</b> TCAParameterProfile_T tcaParameterProfile: contains the 
     * sets of threshold values.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when input parameter are syntactical #
     *  incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when specified Profile does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managed element is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 14:  // performance/PerformanceManagementMgr_I/getTCAParameterProfile
       {
         try {
           globaldefs.NameAndStringValue_T tcaParameterProfileName[] = globaldefs.NamingAttributes_THelper.read (in);
           performance.TCAParameterProfile_THolder tcaParameterProfile = new performance.TCAParameterProfile_THolder ();
           this.getTCAParameterProfile (tcaParameterProfileName, tcaParameterProfile);
           out = $rh.createReply();
           performance.TCAParameterProfile_THelper.write (out, tcaParameterProfile.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation configures all threshold values of a TCA Parameter 
     * Profile and overwrites all the existing threshold values of the profile 
     * with the new provided threshold values.
     * All threshold values of all TPs associated to this Profile will be changed
     * according to the new values.
     * Note: This includes also deletion of thresholds if the threshold is no 
     * longer contained in the provided list of TCA Parameters.
     * The EMS has to return all TPs that could not be changed to the new 
     * threshold values due to some error reasons.<p>
     *
     * <br><b>in</b> globaldefs::NamingAttributes_T tcaParameterProfileName: 
     * name of the profile to be configured.
     * <br><b>in</b> TCAParameterList_T listOfTCAParameter: contains sets of
     * threshold values to change the Profile completely.
     * <br><b>in</b> unsigned long how_many: maximum number of failedTPs to 
     * return in the first batch.
     * <br><b>out</b> TCAParameterProfile_T tcaParameterProfile: returns the
     * changed TCA Parameter Profile.
     * <br><b>out</b> globaldefs::NamingAttributesList_T failedTPList: set of
     * TPs that could not be changed to the new threshold values.
     * <br><b>out</b> globaldefs::NamingAttributesIterator_I nameIt: Iterator to
     * retrieve the remaining failedTP names.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when input parameter are syntactical 
     *  incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when TCA Parameter Profile to be changed 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managed element is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 15:  // performance/PerformanceManagementMgr_I/setTCAParameterProfile
       {
         try {
           globaldefs.NameAndStringValue_T tcaParameterProfileName[] = globaldefs.NamingAttributes_THelper.read (in);
           performance.TCAParameter_T listOfTCAParameter[] = performance.TCAParameterList_THelper.read (in);
           int how_many = in.read_ulong ();
           performance.TCAParameterProfile_THolder tcaParameterProfile = new performance.TCAParameterProfile_THolder ();
           globaldefs.NamingAttributesList_THolder failedTPList = new globaldefs.NamingAttributesList_THolder ();
           globaldefs.NamingAttributesIterator_IHolder nameIt = new globaldefs.NamingAttributesIterator_IHolder ();
           this.setTCAParameterProfile (tcaParameterProfileName, listOfTCAParameter, how_many, tcaParameterProfile, failedTPList, nameIt);
           out = $rh.createReply();
           performance.TCAParameterProfile_THelper.write (out, tcaParameterProfile.value);
           globaldefs.NamingAttributesList_THelper.write (out, failedTPList.value);
           globaldefs.NamingAttributesIterator_IHelper.write (out, nameIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation gets all TCA Parameter Profile names regardless of 
     * whether the profile is assigned to a TP or not.<p>
     *
     * <br><b>in</b> globaldefs::NamingAttributes_T meName: name of the Network
     * Element containing the Profiles.
     * <br><b>in</b> unsigned long how_many: maximum number of 
     * tcaParameterProfile names to return in the first batch.
     * <br><b>out</b> globaldefs::NamingAttributesList_T 
     * tcaParameterProfileNames: contains the names of the existing TCA Parameter 
     * Profiles.
     * <br><b>out</b> globaldefs::NamingAttributesIterator_I nameIt: Iterator to
     * retrieve the remaining tcaParameterProfile names.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when input parameter are syntactical 
     *  incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when specified managed element does not 
     *  exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managed element is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 16:  // performance/PerformanceManagementMgr_I/getAllTCAParameterProfileNames
       {
         try {
           globaldefs.NameAndStringValue_T meName[] = globaldefs.NamingAttributes_THelper.read (in);
           int how_many = in.read_ulong ();
           globaldefs.NamingAttributesList_THolder tcaParameterProfileNames = new globaldefs.NamingAttributesList_THolder ();
           globaldefs.NamingAttributesIterator_IHolder nameIt = new globaldefs.NamingAttributesIterator_IHolder ();
           this.getAllTCAParameterProfileNames (meName, how_many, tcaParameterProfileNames, nameIt);
           out = $rh.createReply();
           globaldefs.NamingAttributesList_THelper.write (out, tcaParameterProfileNames.value);
           globaldefs.NamingAttributesIterator_IHelper.write (out, nameIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation returns the PM history data on a specified list of 
     * TPs.<p>
     *
     * <br>PMTPSelectList_T pmTPSelectList: This struct contains the relevant 
     * data to identify the TPs from which to collect. This must not be empty.
     * <br>PMParameterNameList_T pmParameters. This parameter specifies which PM 
     * parameters within the scope of the pmTPSelectList shall be contained in the 
     * returned data. An empty list means all supported parameters should be 
     * returned. The returned parameters are best effort, i.e. among the 
     * parameters specified only the subset of supported parameters will be 
     * returned.
     * <br>globaldefs::Time_T startTime: Specifies the start of the time window 
     * for collection (included).
     * <br>globaldefs::Time_T endTime: Specifies the end of the time window for 
     * collection (excluded).
     * <br>unsigned long how_many: maximum number of PMData to return in the 
     * first batch.
     * <br>PMDataList_T pmDataList: first batch of PMData returned.
     * <br>PMDataIterator_I pmIt: iterator returned to access the remaining 
     * PMData.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when EMS does not support history PM for 
     *  the time specified by NMS<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is not well 
     *  formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when one of the TP does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to the NE is down<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     **/
       case 17:  // performance/PerformanceManagementMgr_I/getTPHistoryPMData
       {
         try {
           performance.PMTPSelect_T pmTPSelectList[] = performance.PMTPSelectList_THelper.read (in);
           String pmParameters[] = performance.PMParameterNameList_THelper.read (in);
           String startTime = globaldefs.Time_THelper.read (in);
           String endTime = globaldefs.Time_THelper.read (in);
           int how_many = in.read_ulong ();
           performance.PMDataList_THolder pmDataList = new performance.PMDataList_THolder ();
           performance.PMDataIterator_IHolder pmIt = new performance.PMDataIterator_IHolder ();
           this.getTPHistoryPMData (pmTPSelectList, pmParameters, startTime, endTime, how_many, pmDataList, pmIt);
           out = $rh.createReply();
           performance.PMDataList_THelper.write (out, pmDataList.value);
           performance.PMDataIterator_IHelper.write (out, pmIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation allows an NMS to retrieve all PMPs contained in a TP or 
     * ME specified.</p> 
     *
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     *
     * <br>globaldefs::NamingAttributes_T name: The name of the object to which 
     * this selection applies. This may be: 
     * <ul>
     * <li>ManagedElement: The selection applies to all termination points  
     * contained within the ManagedElement.</li>
     * <li>TerminationPoint: The selection applies only to the named termination 
     * point which will be a PTP, FTP or a CTP. Unlike the case for 
     * managedElement, the operation will not apply to any contained TPs when a 
     * PTP, FTP or CTP is specified.</li>
     * </ul>
     * <br>performance::PMPList_T pmpList nameList: First batch of PMPs. 
     * <br>performance::PMPIterator_I pmpIt: Iterator to retrieve remaining 
     * PMPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if an EMS does not implement this 
     *  operation<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when references an object of type 
     *  other than ME or TP<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tpOrMeName references an object 
     *  that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 18:  // performance/PerformanceManagementMgr_I/getAllPMPs
       {
         try {
           globaldefs.NameAndStringValue_T tpOrMeName[] = globaldefs.NamingAttributes_THelper.read (in);
           int how_many = in.read_ulong ();
           performance.PMPList_THolder pmpList = new performance.PMPList_THolder ();
           performance.PMPIterator_IHolder pmpIt = new performance.PMPIterator_IHolder ();
           this.getAllPMPs (tpOrMeName, how_many, pmpList, pmpIt);
           out = $rh.createReply();
           performance.PMPList_THelper.write (out, pmpList.value);
           performance.PMPIterator_IHelper.write (out, pmpIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation has exactly the same behaviour as 
     * getAllPMPs(), but instead of returning the 
     * entire object structures, this operation returns their names.</p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     *
     * <br>globaldefs::NamingAttributes_T name: The name of the object to which 
     * this selection applies. This may be: 
     * <ul>
     * <li>ManagedElement: The selection applies to all termination points  
     * contained within the ManagedElement.</li>
     * <li>TerminationPoint: The selection applies only to the named termination 
     * point which will be a PTP, FTP or a CTP. Unlike the case for 
     * managedElement, the operation will not apply to any contained TPs when a 
     * PTP, FTP or CTP is specified.</li>
     * </ul>
     * <br>unsigned long how_many: Maximum number of PMP names to return
     * in the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList: First batch of PMP 
     * names.
     * <br>globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve 
     * the remaining PMP names.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException
     * As for getAllPMPs().
     **/
       case 19:  // performance/PerformanceManagementMgr_I/getAllPMPNames
       {
         try {
           globaldefs.NameAndStringValue_T tpOrMeName[] = globaldefs.NamingAttributes_THelper.read (in);
           int how_many = in.read_ulong ();
           globaldefs.NamingAttributesList_THolder nameList = new globaldefs.NamingAttributesList_THolder ();
           globaldefs.NamingAttributesIterator_IHolder nameIt = new globaldefs.NamingAttributesIterator_IHolder ();
           this.getAllPMPNames (tpOrMeName, how_many, nameList, nameIt);
           out = $rh.createReply();
           globaldefs.NamingAttributesList_THelper.write (out, nameList.value);
           globaldefs.NamingAttributesIterator_IHelper.write (out, nameIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation adds/removes TCA Parameter Profiles to/from the TP.
     * The new threshold values contained in the added profiles will be copied to 
     * the corresponding PMPs of the TP. The addition of an already associated 
     * profile to a TP overwrites the corresponding thresholds in the PMPs of the 
     * TP. The threshold values that have been configured via a profile to be 
     * removed will be kept in the PMPs.</p>
     * 
     * <p>Notes:<ul>
     * <li>No further automatic updating based on changes in the profile will be 
     * done.</li>
     * <li>This operation can also be used to align the TCA Thresholds of all PMPs 
     * contained in the TP with the threshold values contained in the associated 
     * TCA Parameter Profile and is therefore idempotent.</li></ul><p>
     *
     * <br>globaldefs::NamingAttributes_T tpName: The name of the TP to which to 
     * assign the pointer to the TCA parameter profile.
     * <br><b>in</b> globaldefs::NamingAttributes_T addTCAParameterProfile: the 
     * name of the TCAParameterProfile to be added to this TP.
     * <br><b>in</b> globaldefs::NamingAttributes_T removeTCAParameterProfile: 
     * the name of the TCAParameterProfile to be removed from this TP.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when input parameter are syntactical 
     *  incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - - Raised when tpName references an object that 
     *  does not exist or when TCAParameterProfile to be assigned 
     *  does not exist<br>
     * EXCPT_OBJECT_IN_USE - Raised when TCAParameterProfile of same Layer is 
     *  already assigned to the TP<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when threshold values in the TP could not 
     *  be configured<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managed element is 
     *  lost<br>
     * <br>
     **/
       case 20:  // performance/PerformanceManagementMgr_I/setTCAParameterProfilePointer
       {
         try {
           globaldefs.NameAndStringValue_T tpName[] = globaldefs.NamingAttributes_THelper.read (in);
           globaldefs.NameAndStringValue_T addTCAParameterProfile[] = globaldefs.NamingAttributes_THelper.read (in);
           globaldefs.NameAndStringValue_T removeTCAParameterProfile[] = globaldefs.NamingAttributes_THelper.read (in);
           this.setTCAParameterProfilePointer (tpName, addTCAParameterProfile, removeTCAParameterProfile);
           out = $rh.createReply();
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation allows an NMS to request all the TCA parameter 
     * profiles associated with the specified managed element.</p>
     *
     * <p>In order to allow the NMS to deal with a large number of 
     * objects, this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     *
     * <br>globaldefs::NamingAttributes_T metName: Name of the 
     * managed element containing the TCA parameter profiles.
     * <br>unsigned long how_many: Maximum number of TCA parameter 
     * profiles to return in the first batch.
     * <br>TCAParameterProfileList_T tcaParameterProfileList: The first batch of 
     * TCA parameter profiles.
     * <br>managedElement::TCAParameterProfileIterator_I tcaParameterProfileIt: 
     * Iterator to retrieve the remaining TCA parameter profiles.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when the EMS does not support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when meName does not reference a 
     *  managed element object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when meName references an object 
     * that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement 
     * is lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of
     * iterators that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
    * <br>
     **/
       case 21:  // performance/PerformanceManagementMgr_I/getAllTCAParameterProfiles
       {
         try {
           globaldefs.NameAndStringValue_T meName[] = globaldefs.NamingAttributes_THelper.read (in);
           int how_many = in.read_ulong ();
           performance.TCAParameterProfileList_THolder tcaParameterProfileList = new performance.TCAParameterProfileList_THolder ();
           performance.TCAParameterProfileIterator_IHolder tcaParameterProfileIt = new performance.TCAParameterProfileIterator_IHolder ();
           this.getAllTCAParameterProfiles (meName, how_many, tcaParameterProfileList, tcaParameterProfileIt);
           out = $rh.createReply();
           performance.TCAParameterProfileList_THelper.write (out, tcaParameterProfileList.value);
           performance.TCAParameterProfileIterator_IHelper.write (out, tcaParameterProfileIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>The nativeEMSName is owned by the EMS.  It represents how an EMS user 
     * addresses an object on the EMS GUI.  The EMS may or may not support 
     * changing this value.</p>
     *
     * <p>When an object is created by the EMS, the EMS selects the nativeEMSName 
     * for the object.</p>
     *
     * <p>When an object is created by an NMS, the NMS specifies the userLabel for  
     * the object. If the EMS supports setting of nativeEMSNames, the 
     * nativeEMSName should be set to the same value as the userLabel.  If the EMS 
     * does not support setting of nativeEMSNames, or if the nativeEMSName has 
     * constraints that the userLabel does not satisfy, the EMS selects the 
     * nativeEMSName for the object.</p>
     *
     * <p>After an object has been created, the nativeEMSName may be changed by 
     * the NMS, if the EMS supports this functionality, using the setNativeEMSName 
     * operation.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName
     * <br> string nativeEMSName
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which 
     *  does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the nativeEMSName can not be set for 
     *  the specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost
     * <br>
     **/
       case 22:  // common/Common_I/setNativeEMSName
       {
         try {
           globaldefs.NameAndStringValue_T objectName[] = globaldefs.NamingAttributes_THelper.read (in);
           String nativeEMSName = in.read_string ();
           this.setNativeEMSName (objectName, nativeEMSName);
           out = $rh.createReply();
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>The userLabel is owned by the NMSes.  It is a string assigned by an NMS 
     * to an object. The difference between the userLabel and the NamingAttributes 
     * name is that the userLabel is an attribute of the objects that 
     * may be "set" by the NMS through well defined interfaces (setUserLabel).</p>
     *
     * <p>When an object is created by an NMS, the NMS specifies the userLabel for 
     * the object.</p>
     *
     * <p>When an object is created by the EMS, the EMS sets the userLabel to the 
     * nativeEMSName.</p>
     *
     * <p>Once an object is created, the userLabel may only be changed by an NMS 
     * through the setUserLabel operation.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName: Name of the object for 
     *  which to change the userLabel.
     * <br> string userLabel: New user label to assign to the object
     * <br> boolean enforceUniqueness: Specifies whether or not userLabel should 
     * be checked for uniqueness amongst objects of the same class within the EMS.  
     * If true, then the operation will fail if userLabel is already in use.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which 
     *  does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the userLabel can not be set for the 
     *  specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * <br>
     **/
       case 23:  // common/Common_I/setUserLabel
       {
         try {
           globaldefs.NameAndStringValue_T objectName[] = globaldefs.NamingAttributes_THelper.read (in);
           String userLabel = in.read_string ();
           boolean enforceUniqueness = in.read_boolean ();
           this.setUserLabel (objectName, userLabel, enforceUniqueness);
           out = $rh.createReply();
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /** 
     * <p>This service sets the owner attribute of the specified object.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName
     * <br> string owner
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
     *  that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the owner can not be set for the 
     *  specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
       case 24:  // common/Common_I/setOwner
       {
         try {
           globaldefs.NameAndStringValue_T objectName[] = globaldefs.NamingAttributes_THelper.read (in);
           String owner = in.read_string ();
           this.setOwner (objectName, owner);
           out = $rh.createReply();
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /** 
     * <p>This service retrieves the capabilities of the manager.
     * All non-specified capabilities are assumed to be unsupported.</p>
     *
     * <br> CapabilityList_T capabilities
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, and cannot determine the reason it could not comply, it may raise this exception. <br>
     **/
       case 25:  // common/Common_I/getCapabilities
       {
         try {
           common.CapabilityList_THolder capabilities = new common.CapabilityList_THolder ();
           this.getCapabilities (capabilities);
           out = $rh.createReply();
           common.CapabilityList_THelper.write (out, capabilities.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This service sets the additional info attribute
     * of the object identified by objectName. This operation should be used
     * to set both vendor specific attributes as well as the attributes that
     * are formally defined in this interface specification. See <a 
     * href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     * Additional Information Usage</a> for further details.</p>
     *
     * <p>As an input only the list of parameters to be changed, removed, or
     * added shall be provided.  If an entry is to be removed, "-" shall
     * be specified as a value.  If a parameter is specified that is currently
     * not part of the additionalInfo attribute of the specified object
     * that parameter is added by the EMS with the specified value.
     * The EMS may reject removal and addition requests, however.</p>
     *
     * <p> The operation is best effort (except where specified otherwise for a 
     * particular parameter).  The output specifies the
     * values which were actually set.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName: the managed object
     * whose additional info parameters are intended to get modified
     *
     * <br> globaldefs::NVSList_T additionalInfo: list of parameters
     * to be changed, added, or removed (input), updated to provide the
     * actually changed or added parameters (output)
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal
     *  failure (see errorReason attribute of ProcessingFailureException())<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed,
     *  raised when an input parameter is syntactical incorrect and raised when a 
     *  parameter is identified as only "settable" using a "specific operation" in 
     *  the <a href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     *  Additional Information Usage</a> document<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
     *  that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when the communication to the managed
     *  element containing or hosting objectName is lost<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable 
     *  to execute the request because at least one of the parameters although 
     *  valid can not be set and that parameter is identified as "not best effort" 
     *  in the <a href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     *  Additional Information Usage</a> document)<br>
     * <br>
  
     **/
       case 26:  // common/Common_I/setAdditionalInfo
       {
         try {
           globaldefs.NameAndStringValue_T objectName[] = globaldefs.NamingAttributes_THelper.read (in);
           globaldefs.NVSList_THolder additionalInfo = new globaldefs.NVSList_THolder ();
           additionalInfo.value = globaldefs.NVSList_THelper.read (in);
           this.setAdditionalInfo (objectName, additionalInfo);
           out = $rh.createReply();
           globaldefs.NVSList_THelper.write (out, additionalInfo.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }

       default:
         throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
    }

    return out;
  } // _invoke

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:mtnm.tmforum.org/performance/PerformanceManagementMgr_I:1.0", 
    "IDL:mtnm.tmforum.org/common/Common_I:1.0"};

  public String[] _all_interfaces (org.omg.PortableServer.POA poa, byte[] objectId)
  {
    return (String[])__ids.clone ();
  }

  public PerformanceManagementMgr_I _this() 
  {
    return PerformanceManagementMgr_IHelper.narrow(
    super._this_object());
  }

  public PerformanceManagementMgr_I _this(org.omg.CORBA.ORB orb) 
  {
    return PerformanceManagementMgr_IHelper.narrow(
    super._this_object(orb));
  }


} // class PerformanceManagementMgr_IPOA
