package protection;


/**
* protection/ProtectionMgr_IOperations.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from protection.idl
* Wednesday, June 15, 2016 7:24:41 PM COT
*/


/**
   * <p>The ProtectionMgr_I is used to gain access to protection groups and
   * their operations.</p>
   **/
public interface ProtectionMgr_IOperations  extends common.Common_IOperations
{

  /**
     * <p>This operation is used by the client to discover all the 
     * protection groups currently in operation for the managed
     * element.</p>
     *
     * <br>globaldefs::NamingAttributes_T meName:
     * the name of the managed element for which the request is made.
     * <br>unsigned long how_many: Maximum number of protection groups 
     * to report in the first batch.
     * <br>ProtectionGroupList_T pgList: First batch of protection groups.
     * <br>ProtectionGroupIterator_I pgIt: Iterator used to access the 
     * remaining PGs, if any.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when meName does not reference a 
     *  managedElement object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when meName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * <br>
     **/
  void getAllProtectionGroups (globaldefs.NameAndStringValue_T[] meName, int how_many, protection.ProtectionGroupList_THolder pgList, protection.ProtectionGroupIterator_IHolder pgpIt) throws globaldefs.ProcessingFailureException;

  /**
     * <p>This operation is used by the client to discover all the 
     * equipment protection groups currently in operation for the managed
     * element.</p>
     *
     * <br>globaldefs::NamingAttributes_T meName:
     * the name of the managed element for which the request is made.
     * <br>unsigned long how_many: Maximum number of equipment protection 
     * groups to report in the first batch.
     * <br>EProtectionGroupList_T epgpList: First batch of equipment protection 
     * groups.
     * <br>EProtectionGroupIterator_I epgpIt: Iterator used to access the 
     * remaining EPGs, if any.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when meName does not reference a 
     *  managedElement object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when meName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  void getAllEProtectionGroups (globaldefs.NameAndStringValue_T[] meName, int how_many, protection.EProtectionGroupList_THolder epgpList, protection.EProtectionGroupIterator_IHolder epgpIt) throws globaldefs.ProcessingFailureException;

  /**
     * <p>This operation is used to get the current status of a 
     * protectionGroup. This service is needed so that even if a filter
     * is established, the NMS can query the status of a protection 
     * group.</p>
     *
     * <br>globaldefs::NamingAttributes_T protectionGroupName:
     * the name of the protection Group that the client is
     * interested in.
     * <br>protection::ProtectionGroup_T protectionGroup: the returned 
     * protection group.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a protection 
     *  group<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references a PG object that 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
  void getProtectionGroup (globaldefs.NameAndStringValue_T[] pgName, protection.ProtectionGroup_THolder protectionGroup) throws globaldefs.ProcessingFailureException;

  /**
     * <p>This operation is used to get the current status of a 
     * Equipment Protection Group. This service is needed so that even if a 
     * filter is established, the NMS can query the status of a 
     * protection group.</p>
     *
     * <br>globaldefs::NamingAttributes_T ePGPname:
     * the name of the equipment protection group that the client is
     * interested in.
     * <br>protection::EProtectionGroup_T eProtectionGroup: the returned 
     * equipment protection group.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INVALID_INPUT - Raised when ePGPName does not reference an equipment  
     *  protection group<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when ePGPName references an object which 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  void getEProtectionGroup (globaldefs.NameAndStringValue_T[] ePGPname, protection.EProtectionGroup_THolder eProtectionGroup) throws globaldefs.ProcessingFailureException;

  /**
     * <p>This operation gets the list of names of CTPs that are configured to 
     * carry Non-preemptible Unprotected extra Traffic.  The result is independent 
     * of the current switch status.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     *
     * <br>globaldefs::NamingAttributes_T groupName:
     * Name of the protection group.
     * <br>unsigned long how_many:
     * Maximum number of CTPs to be returned in the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList:
     * The first batch of CTPs that have NUT turned on.
     * <br>globaldefs::NamingAttributesIterator_I nameIt:
     * The iterator used to retrieve the remaining CTPs that have NUT turned 
     * on.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a 
     *  protectionGroup object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators
     *  that the EMS can support has been reached.
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  void getAllNUTTPNames (globaldefs.NameAndStringValue_T[] pgName, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException;

  /**
     * <p>This operation gets the list of names of CTPs that can carry preemptible 
     * extra traffic.  The result is independent of the current
     * switch status.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     *
     * <br>globaldefs::NamingAttributes_T groupName:
     * Name of the protection group.
     * <br>unsigned long how_many:
     * Maximum number of CTPs to be returned in the first batch.
     * <br>globaldefs::NamingAttributesList_T tpNameList:
     * The first batch of CTPs that can carry preemptible extra traffic.
     * <br>globaldefs::NamingAttributesIterator_I tpit:
     * The iterator used to retrieve the remaining CTPs that can carry 
     * preemptible extra traffic.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a 
     *  protectionGroup object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators
     *  that the EMS can support has been reached.
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  void getAllPreemptibleTPNames (globaldefs.NameAndStringValue_T[] pgName, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException;

  /**
     * <p>This operation gets the list of CTPs that can carry protected
     * traffic. The result is independent of the current
     * switch status.</p>
     * 
     * <br>globaldefs::NamingAttributes_T pgName:
     * Name of the protection group.
     * <br>unsigned long how_many:
     * Maximum number of CTPs to be returned in the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList:
     * The first batch of CTPs that can carry protected traffic.
     * <br>globaldefs::NamingAttributesIterator_I nameIt:
     * The iterator used to retrieve the remaining CTPs that can carry 
     * protected traffic.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a 
     *  protectionGroup object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached.
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  void getAllProtectedTPNames (globaldefs.NameAndStringValue_T[] pgName, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException;

  /**
     * <p>This service is used by the NMS to get the latest switch status
     * on a SNC or a MSP group.
     * <p>It should be noted that although the term MSP was chosen 
     * as the original specific protection scheme to which the related behaviour
     * applied was Multiplex Section Protection, the label is now more generally 
     * applied to any 1+1 or 1:N Trail protection scheme.</p> 
     *
     * <p>When used on the reliable CTP/FTP of an SNC, a single struct is returned 
     * and the group name is NULL. The switchToTP indicates the presently active
     * source of the traffic to the protectedTP.
     *
     * <p> When used on a 1+1 MSP, a single struct is provided with the 
     * relevant data.
     *
     * <p> When used on a 1:N MSP, a struct per worker TP is presented with
     * protectedTP being the worker TP Name and the switchToTP identifying
     * the present source of the traffic.
     *
     * <p> When used on a 2F BLSR, two structs are returned, one per TP. 
     * In a stable state, the protectedTP and the switchToTP are the same TP. 
     * In a switched state, the switchToTP is the same for both protectedTPs.
     *
     * <p> When used on a 4F BLSR, two structs are returned,
     * each one identifying a span with the protectedTP being the worker TP 
     * and the switchToTP identifying the present source of the ring traffic
     * for that span.
     *
     * <p>See <a href=../../../supportingDocumentation/SD1-34_protectionSwitch.pdf >SD1-34 
     * Protection Switch</a>
     * for more information.</p>
     *
     * <br>globaldefs::NamingAttributes_T reliableSinkCtpOrGroupName:
     * This is the CTP/FTP that is the output of a service selector in 
     * case of the SNC or the group name for which the switch data is 
     * being requested. The termination point name must be explicit (a 
     * generic endpoint specification may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>protection::SwitchDataList_T: The current protection switch status
     * of the CTP, FTP or PG provided.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when reliableSinkCtpOrGroupName does not 
     *  reference a reliable CTP nor FTP nor PG object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when reliableSinkCtpOrGroupName references 
     *  a CTP or FTP or PG or object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
    * <br>
     **/
  void retrieveSwitchData (globaldefs.NameAndStringValue_T[] reliableSinkCtpOrGroupName, protection.SwitchDataList_THolder switchData) throws globaldefs.ProcessingFailureException;

  /**
     * <p>This service is used by the NMS to get the latest switch status
     * on an equipment protection group.<br>
     *
     * For a retrieval of a revertive M:N group, N ESwitchData_T 
     * are returned as a result of retrieveESwitchData (one for 
     * each worker equipment instance).<br>
     * 
     * For a retrieval of a non-revertive M:N group, N ESwitchData_T 
     * are returned as a result of retrieveESwitchData (one for 
     * each active equipment instance).<br>
     * 
     * <br>globaldefs::NamingAttributes_T ePGPName:
     * This is the equipment protection group name for which 
     * the switch data is being requested.
     *       
     * <br>protection::ESwitchDataList_T: The current protection switch status
     * of the equipment protection group provided.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when ePGPName does not reference an equipment 
     *  object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when ePGPName references object which does
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  void retrieveESwitchData (globaldefs.NameAndStringValue_T[] ePGPName, protection.ESwitchDataList_THolder eSwitchDataList) throws globaldefs.ProcessingFailureException;

  /**
     * <p> This service is used to execute a protection switch. The protection
     * switch may be performed via a protection switch command, on a protection 
     * group or on a CTP/FTP involved in an 
     * SNCP. The NMS requests the EMS to move the traffic received from the fromTP
     * to the toTP.  The same command is used to clear all existing commands.</p>
     * 
     * <p>For 4-fiber SONET/SDH SPRINGS, the span switch is performed on the   
     * PGT_MSP_1_FOR_N protection group, and the ring switch on the 
     * PGT_4_FIBER_BLSR group.</p>
     * 
     * <p>See 
     * <a href=../../../supportingDocumentation/SD1-34_protectionSwitch.pdf >SD1-34 Protection Switch</a>
     * for more information.</p>
     *
     * <p>It should be noted that although the term MSP was chosen 
     * as the original specific protection scheme to which the related behaviour
     * applied was Multiplex Section Protection, the label is now more generally 
     * applied to any 1+1 or 1:N Trail protection scheme.</p>
     * <br>ProtectionCommand_T protectionCommand: The command to be performed
     * <br>globaldefs::NamingAttributes_T reliableSinkCtpOrGroupName:
     * This is the CTP/FTP that is the output of a service selector in 
     * case of the SNC or the group name for which the switch data is 
     * being requested. The termination point name must be explicit (a 
     * generic endpoint specification may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>globaldefs::NamingAttributes_T fromTp: The present source of
     * the traffic. The termination point name must be explicit (a generic 
     * endpoint specification may not be used in this case).
     * <br>globaldefs::NamingAttributes_T toTp:   The requested source of
     * the traffic after the command. The termination point name must be 
     * explicit (a generic endpoint specification may not be used in this 
     * case).
     * <br>protection::SwitchData_T switchData: The protection switch status
     * of the toTp provided after the execution of the command.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when reliableSinkCtpOrGroupName, fromTp, or 
     *  toTp do not reference objects of the correct type. Raised when the
     *  reliableSinkCtpOrGroupName, fromTp, or toTp reference objects of the 
     *  correct type, but that are invalid in the context of this operation<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when reliableSinkCtpOrGroupName references  
     *  a CTP, FTP or PG object that does not exist, or when fromTp or toTp 
     *  references a CTP/FTP object that does not exist <br>
     * EXCPT_UNABLE_TO_COMPLY - Raised if the EMS is unable to perform the 
     *  operation<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to the managed element is 
     *  lost<br>
     **/
  void performProtectionCommand (protection.ProtectionCommand_T protectionCommand, globaldefs.NameAndStringValue_T[] reliableSinkCtpOrGroupName, globaldefs.NameAndStringValue_T[] fromTp, globaldefs.NameAndStringValue_T[] toTp, protection.SwitchData_THolder switchData) throws globaldefs.ProcessingFailureException;

  /**
     * <p>This service returns the names of the Protection Groups containing the given
     * PhysicalTerminationPoint.</p>
     *
     * <br>globaldefs::NamingAttributes_T pTPName:
     * The name of the PhysicalTerminationPoint.
     * <br>globaldefs::NamingAttributesList_T pgNameList:
     * The names of the containing ProtectionGroups.
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException:<br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
     * EXCPT_INVALID_INPUT - Raised when pTPName is syntactically incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pTPName references a
     *  PhysicalTerminationPointTPPool object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to some ME is lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * 
     **/
  void getContainingPGNames (globaldefs.NameAndStringValue_T[] pTPName, globaldefs.NamingAttributesList_THolder pgNameList) throws globaldefs.ProcessingFailureException;
} // interface ProtectionMgr_IOperations
