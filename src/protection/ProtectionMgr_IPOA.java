package protection;


/**
* protection/ProtectionMgr_IPOA.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from protection.idl
* Wednesday, June 15, 2016 7:24:41 PM COT
*/


/**
   * <p>The ProtectionMgr_I is used to gain access to protection groups and
   * their operations.</p>
   **/
public abstract class ProtectionMgr_IPOA extends org.omg.PortableServer.Servant
 implements protection.ProtectionMgr_IOperations, org.omg.CORBA.portable.InvokeHandler
{

  // Constructors

  private static java.util.Hashtable _methods = new java.util.Hashtable ();
  static
  {
    _methods.put ("getAllProtectionGroups", new java.lang.Integer (0));
    _methods.put ("getAllEProtectionGroups", new java.lang.Integer (1));
    _methods.put ("getProtectionGroup", new java.lang.Integer (2));
    _methods.put ("getEProtectionGroup", new java.lang.Integer (3));
    _methods.put ("getAllNUTTPNames", new java.lang.Integer (4));
    _methods.put ("getAllPreemptibleTPNames", new java.lang.Integer (5));
    _methods.put ("getAllProtectedTPNames", new java.lang.Integer (6));
    _methods.put ("retrieveSwitchData", new java.lang.Integer (7));
    _methods.put ("retrieveESwitchData", new java.lang.Integer (8));
    _methods.put ("performProtectionCommand", new java.lang.Integer (9));
    _methods.put ("getContainingPGNames", new java.lang.Integer (10));
    _methods.put ("setNativeEMSName", new java.lang.Integer (11));
    _methods.put ("setUserLabel", new java.lang.Integer (12));
    _methods.put ("setOwner", new java.lang.Integer (13));
    _methods.put ("getCapabilities", new java.lang.Integer (14));
    _methods.put ("setAdditionalInfo", new java.lang.Integer (15));
  }

  public org.omg.CORBA.portable.OutputStream _invoke (String $method,
                                org.omg.CORBA.portable.InputStream in,
                                org.omg.CORBA.portable.ResponseHandler $rh)
  {
    org.omg.CORBA.portable.OutputStream out = null;
    java.lang.Integer __method = (java.lang.Integer)_methods.get ($method);
    if (__method == null)
      throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);

    switch (__method.intValue ())
    {

  /**
     * <p>This operation is used by the client to discover all the 
     * protection groups currently in operation for the managed
     * element.</p>
     *
     * <br>globaldefs::NamingAttributes_T meName:
     * the name of the managed element for which the request is made.
     * <br>unsigned long how_many: Maximum number of protection groups 
     * to report in the first batch.
     * <br>ProtectionGroupList_T pgList: First batch of protection groups.
     * <br>ProtectionGroupIterator_I pgIt: Iterator used to access the 
     * remaining PGs, if any.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when meName does not reference a 
     *  managedElement object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when meName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * <br>
     **/
       case 0:  // protection/ProtectionMgr_I/getAllProtectionGroups
       {
         try {
           globaldefs.NameAndStringValue_T meName[] = globaldefs.NamingAttributes_THelper.read (in);
           int how_many = in.read_ulong ();
           protection.ProtectionGroupList_THolder pgList = new protection.ProtectionGroupList_THolder ();
           protection.ProtectionGroupIterator_IHolder pgpIt = new protection.ProtectionGroupIterator_IHolder ();
           this.getAllProtectionGroups (meName, how_many, pgList, pgpIt);
           out = $rh.createReply();
           protection.ProtectionGroupList_THelper.write (out, pgList.value);
           protection.ProtectionGroupIterator_IHelper.write (out, pgpIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation is used by the client to discover all the 
     * equipment protection groups currently in operation for the managed
     * element.</p>
     *
     * <br>globaldefs::NamingAttributes_T meName:
     * the name of the managed element for which the request is made.
     * <br>unsigned long how_many: Maximum number of equipment protection 
     * groups to report in the first batch.
     * <br>EProtectionGroupList_T epgpList: First batch of equipment protection 
     * groups.
     * <br>EProtectionGroupIterator_I epgpIt: Iterator used to access the 
     * remaining EPGs, if any.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when meName does not reference a 
     *  managedElement object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when meName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 1:  // protection/ProtectionMgr_I/getAllEProtectionGroups
       {
         try {
           globaldefs.NameAndStringValue_T meName[] = globaldefs.NamingAttributes_THelper.read (in);
           int how_many = in.read_ulong ();
           protection.EProtectionGroupList_THolder epgpList = new protection.EProtectionGroupList_THolder ();
           protection.EProtectionGroupIterator_IHolder epgpIt = new protection.EProtectionGroupIterator_IHolder ();
           this.getAllEProtectionGroups (meName, how_many, epgpList, epgpIt);
           out = $rh.createReply();
           protection.EProtectionGroupList_THelper.write (out, epgpList.value);
           protection.EProtectionGroupIterator_IHelper.write (out, epgpIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation is used to get the current status of a 
     * protectionGroup. This service is needed so that even if a filter
     * is established, the NMS can query the status of a protection 
     * group.</p>
     *
     * <br>globaldefs::NamingAttributes_T protectionGroupName:
     * the name of the protection Group that the client is
     * interested in.
     * <br>protection::ProtectionGroup_T protectionGroup: the returned 
     * protection group.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a protection 
     *  group<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references a PG object that 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
       case 2:  // protection/ProtectionMgr_I/getProtectionGroup
       {
         try {
           globaldefs.NameAndStringValue_T pgName[] = globaldefs.NamingAttributes_THelper.read (in);
           protection.ProtectionGroup_THolder protectionGroup = new protection.ProtectionGroup_THolder ();
           this.getProtectionGroup (pgName, protectionGroup);
           out = $rh.createReply();
           protection.ProtectionGroup_THelper.write (out, protectionGroup.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation is used to get the current status of a 
     * Equipment Protection Group. This service is needed so that even if a 
     * filter is established, the NMS can query the status of a 
     * protection group.</p>
     *
     * <br>globaldefs::NamingAttributes_T ePGPname:
     * the name of the equipment protection group that the client is
     * interested in.
     * <br>protection::EProtectionGroup_T eProtectionGroup: the returned 
     * equipment protection group.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INVALID_INPUT - Raised when ePGPName does not reference an equipment  
     *  protection group<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when ePGPName references an object which 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 3:  // protection/ProtectionMgr_I/getEProtectionGroup
       {
         try {
           globaldefs.NameAndStringValue_T ePGPname[] = globaldefs.NamingAttributes_THelper.read (in);
           protection.EProtectionGroup_THolder eProtectionGroup = new protection.EProtectionGroup_THolder ();
           this.getEProtectionGroup (ePGPname, eProtectionGroup);
           out = $rh.createReply();
           protection.EProtectionGroup_THelper.write (out, eProtectionGroup.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation gets the list of names of CTPs that are configured to 
     * carry Non-preemptible Unprotected extra Traffic.  The result is independent 
     * of the current switch status.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     *
     * <br>globaldefs::NamingAttributes_T groupName:
     * Name of the protection group.
     * <br>unsigned long how_many:
     * Maximum number of CTPs to be returned in the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList:
     * The first batch of CTPs that have NUT turned on.
     * <br>globaldefs::NamingAttributesIterator_I nameIt:
     * The iterator used to retrieve the remaining CTPs that have NUT turned 
     * on.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a 
     *  protectionGroup object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators
     *  that the EMS can support has been reached.
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 4:  // protection/ProtectionMgr_I/getAllNUTTPNames
       {
         try {
           globaldefs.NameAndStringValue_T pgName[] = globaldefs.NamingAttributes_THelper.read (in);
           int how_many = in.read_ulong ();
           globaldefs.NamingAttributesList_THolder nameList = new globaldefs.NamingAttributesList_THolder ();
           globaldefs.NamingAttributesIterator_IHolder nameIt = new globaldefs.NamingAttributesIterator_IHolder ();
           this.getAllNUTTPNames (pgName, how_many, nameList, nameIt);
           out = $rh.createReply();
           globaldefs.NamingAttributesList_THelper.write (out, nameList.value);
           globaldefs.NamingAttributesIterator_IHelper.write (out, nameIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation gets the list of names of CTPs that can carry preemptible 
     * extra traffic.  The result is independent of the current
     * switch status.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     *
     * <br>globaldefs::NamingAttributes_T groupName:
     * Name of the protection group.
     * <br>unsigned long how_many:
     * Maximum number of CTPs to be returned in the first batch.
     * <br>globaldefs::NamingAttributesList_T tpNameList:
     * The first batch of CTPs that can carry preemptible extra traffic.
     * <br>globaldefs::NamingAttributesIterator_I tpit:
     * The iterator used to retrieve the remaining CTPs that can carry 
     * preemptible extra traffic.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a 
     *  protectionGroup object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators
     *  that the EMS can support has been reached.
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 5:  // protection/ProtectionMgr_I/getAllPreemptibleTPNames
       {
         try {
           globaldefs.NameAndStringValue_T pgName[] = globaldefs.NamingAttributes_THelper.read (in);
           int how_many = in.read_ulong ();
           globaldefs.NamingAttributesList_THolder nameList = new globaldefs.NamingAttributesList_THolder ();
           globaldefs.NamingAttributesIterator_IHolder nameIt = new globaldefs.NamingAttributesIterator_IHolder ();
           this.getAllPreemptibleTPNames (pgName, how_many, nameList, nameIt);
           out = $rh.createReply();
           globaldefs.NamingAttributesList_THelper.write (out, nameList.value);
           globaldefs.NamingAttributesIterator_IHelper.write (out, nameIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This operation gets the list of CTPs that can carry protected
     * traffic. The result is independent of the current
     * switch status.</p>
     * 
     * <br>globaldefs::NamingAttributes_T pgName:
     * Name of the protection group.
     * <br>unsigned long how_many:
     * Maximum number of CTPs to be returned in the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList:
     * The first batch of CTPs that can carry protected traffic.
     * <br>globaldefs::NamingAttributesIterator_I nameIt:
     * The iterator used to retrieve the remaining CTPs that can carry 
     * protected traffic.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a 
     *  protectionGroup object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached.
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 6:  // protection/ProtectionMgr_I/getAllProtectedTPNames
       {
         try {
           globaldefs.NameAndStringValue_T pgName[] = globaldefs.NamingAttributes_THelper.read (in);
           int how_many = in.read_ulong ();
           globaldefs.NamingAttributesList_THolder nameList = new globaldefs.NamingAttributesList_THolder ();
           globaldefs.NamingAttributesIterator_IHolder nameIt = new globaldefs.NamingAttributesIterator_IHolder ();
           this.getAllProtectedTPNames (pgName, how_many, nameList, nameIt);
           out = $rh.createReply();
           globaldefs.NamingAttributesList_THelper.write (out, nameList.value);
           globaldefs.NamingAttributesIterator_IHelper.write (out, nameIt.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This service is used by the NMS to get the latest switch status
     * on a SNC or a MSP group.
     * <p>It should be noted that although the term MSP was chosen 
     * as the original specific protection scheme to which the related behaviour
     * applied was Multiplex Section Protection, the label is now more generally 
     * applied to any 1+1 or 1:N Trail protection scheme.</p> 
     *
     * <p>When used on the reliable CTP/FTP of an SNC, a single struct is returned 
     * and the group name is NULL. The switchToTP indicates the presently active
     * source of the traffic to the protectedTP.
     *
     * <p> When used on a 1+1 MSP, a single struct is provided with the 
     * relevant data.
     *
     * <p> When used on a 1:N MSP, a struct per worker TP is presented with
     * protectedTP being the worker TP Name and the switchToTP identifying
     * the present source of the traffic.
     *
     * <p> When used on a 2F BLSR, two structs are returned, one per TP. 
     * In a stable state, the protectedTP and the switchToTP are the same TP. 
     * In a switched state, the switchToTP is the same for both protectedTPs.
     *
     * <p> When used on a 4F BLSR, two structs are returned,
     * each one identifying a span with the protectedTP being the worker TP 
     * and the switchToTP identifying the present source of the ring traffic
     * for that span.
     *
     * <p>See <a href=../../../supportingDocumentation/SD1-34_protectionSwitch.pdf >SD1-34 
     * Protection Switch</a>
     * for more information.</p>
     *
     * <br>globaldefs::NamingAttributes_T reliableSinkCtpOrGroupName:
     * This is the CTP/FTP that is the output of a service selector in 
     * case of the SNC or the group name for which the switch data is 
     * being requested. The termination point name must be explicit (a 
     * generic endpoint specification may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>protection::SwitchDataList_T: The current protection switch status
     * of the CTP, FTP or PG provided.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when reliableSinkCtpOrGroupName does not 
     *  reference a reliable CTP nor FTP nor PG object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when reliableSinkCtpOrGroupName references 
     *  a CTP or FTP or PG or object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
    * <br>
     **/
       case 7:  // protection/ProtectionMgr_I/retrieveSwitchData
       {
         try {
           globaldefs.NameAndStringValue_T reliableSinkCtpOrGroupName[] = globaldefs.NamingAttributes_THelper.read (in);
           protection.SwitchDataList_THolder switchData = new protection.SwitchDataList_THolder ();
           this.retrieveSwitchData (reliableSinkCtpOrGroupName, switchData);
           out = $rh.createReply();
           protection.SwitchDataList_THelper.write (out, switchData.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This service is used by the NMS to get the latest switch status
     * on an equipment protection group.<br>
     *
     * For a retrieval of a revertive M:N group, N ESwitchData_T 
     * are returned as a result of retrieveESwitchData (one for 
     * each worker equipment instance).<br>
     * 
     * For a retrieval of a non-revertive M:N group, N ESwitchData_T 
     * are returned as a result of retrieveESwitchData (one for 
     * each active equipment instance).<br>
     * 
     * <br>globaldefs::NamingAttributes_T ePGPName:
     * This is the equipment protection group name for which 
     * the switch data is being requested.
     *       
     * <br>protection::ESwitchDataList_T: The current protection switch status
     * of the equipment protection group provided.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when ePGPName does not reference an equipment 
     *  object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when ePGPName references object which does
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
       case 8:  // protection/ProtectionMgr_I/retrieveESwitchData
       {
         try {
           globaldefs.NameAndStringValue_T ePGPName[] = globaldefs.NamingAttributes_THelper.read (in);
           protection.ESwitchDataList_THolder eSwitchDataList = new protection.ESwitchDataList_THolder ();
           this.retrieveESwitchData (ePGPName, eSwitchDataList);
           out = $rh.createReply();
           protection.ESwitchDataList_THelper.write (out, eSwitchDataList.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p> This service is used to execute a protection switch. The protection
     * switch may be performed via a protection switch command, on a protection 
     * group or on a CTP/FTP involved in an 
     * SNCP. The NMS requests the EMS to move the traffic received from the fromTP
     * to the toTP.  The same command is used to clear all existing commands.</p>
     * 
     * <p>For 4-fiber SONET/SDH SPRINGS, the span switch is performed on the   
     * PGT_MSP_1_FOR_N protection group, and the ring switch on the 
     * PGT_4_FIBER_BLSR group.</p>
     * 
     * <p>See 
     * <a href=../../../supportingDocumentation/SD1-34_protectionSwitch.pdf >SD1-34 Protection Switch</a>
     * for more information.</p>
     *
     * <p>It should be noted that although the term MSP was chosen 
     * as the original specific protection scheme to which the related behaviour
     * applied was Multiplex Section Protection, the label is now more generally 
     * applied to any 1+1 or 1:N Trail protection scheme.</p>
     * <br>ProtectionCommand_T protectionCommand: The command to be performed
     * <br>globaldefs::NamingAttributes_T reliableSinkCtpOrGroupName:
     * This is the CTP/FTP that is the output of a service selector in 
     * case of the SNC or the group name for which the switch data is 
     * being requested. The termination point name must be explicit (a 
     * generic endpoint specification may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>globaldefs::NamingAttributes_T fromTp: The present source of
     * the traffic. The termination point name must be explicit (a generic 
     * endpoint specification may not be used in this case).
     * <br>globaldefs::NamingAttributes_T toTp:   The requested source of
     * the traffic after the command. The termination point name must be 
     * explicit (a generic endpoint specification may not be used in this 
     * case).
     * <br>protection::SwitchData_T switchData: The protection switch status
     * of the toTp provided after the execution of the command.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when reliableSinkCtpOrGroupName, fromTp, or 
     *  toTp do not reference objects of the correct type. Raised when the
     *  reliableSinkCtpOrGroupName, fromTp, or toTp reference objects of the 
     *  correct type, but that are invalid in the context of this operation<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when reliableSinkCtpOrGroupName references  
     *  a CTP, FTP or PG object that does not exist, or when fromTp or toTp 
     *  references a CTP/FTP object that does not exist <br>
     * EXCPT_UNABLE_TO_COMPLY - Raised if the EMS is unable to perform the 
     *  operation<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to the managed element is 
     *  lost<br>
     **/
       case 9:  // protection/ProtectionMgr_I/performProtectionCommand
       {
         try {
           protection.ProtectionCommand_T protectionCommand = protection.ProtectionCommand_THelper.read (in);
           globaldefs.NameAndStringValue_T reliableSinkCtpOrGroupName[] = globaldefs.NamingAttributes_THelper.read (in);
           globaldefs.NameAndStringValue_T fromTp[] = globaldefs.NamingAttributes_THelper.read (in);
           globaldefs.NameAndStringValue_T toTp[] = globaldefs.NamingAttributes_THelper.read (in);
           protection.SwitchData_THolder switchData = new protection.SwitchData_THolder ();
           this.performProtectionCommand (protectionCommand, reliableSinkCtpOrGroupName, fromTp, toTp, switchData);
           out = $rh.createReply();
           protection.SwitchData_THelper.write (out, switchData.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This service returns the names of the Protection Groups containing the given
     * PhysicalTerminationPoint.</p>
     *
     * <br>globaldefs::NamingAttributes_T pTPName:
     * The name of the PhysicalTerminationPoint.
     * <br>globaldefs::NamingAttributesList_T pgNameList:
     * The names of the containing ProtectionGroups.
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException:<br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
     * EXCPT_INVALID_INPUT - Raised when pTPName is syntactically incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pTPName references a
     *  PhysicalTerminationPointTPPool object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to some ME is lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * 
     **/
       case 10:  // protection/ProtectionMgr_I/getContainingPGNames
       {
         try {
           globaldefs.NameAndStringValue_T pTPName[] = globaldefs.NamingAttributes_THelper.read (in);
           globaldefs.NamingAttributesList_THolder pgNameList = new globaldefs.NamingAttributesList_THolder ();
           this.getContainingPGNames (pTPName, pgNameList);
           out = $rh.createReply();
           globaldefs.NamingAttributesList_THelper.write (out, pgNameList.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>The nativeEMSName is owned by the EMS.  It represents how an EMS user 
     * addresses an object on the EMS GUI.  The EMS may or may not support 
     * changing this value.</p>
     *
     * <p>When an object is created by the EMS, the EMS selects the nativeEMSName 
     * for the object.</p>
     *
     * <p>When an object is created by an NMS, the NMS specifies the userLabel for  
     * the object. If the EMS supports setting of nativeEMSNames, the 
     * nativeEMSName should be set to the same value as the userLabel.  If the EMS 
     * does not support setting of nativeEMSNames, or if the nativeEMSName has 
     * constraints that the userLabel does not satisfy, the EMS selects the 
     * nativeEMSName for the object.</p>
     *
     * <p>After an object has been created, the nativeEMSName may be changed by 
     * the NMS, if the EMS supports this functionality, using the setNativeEMSName 
     * operation.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName
     * <br> string nativeEMSName
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which 
     *  does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the nativeEMSName can not be set for 
     *  the specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost
     * <br>
     **/
       case 11:  // common/Common_I/setNativeEMSName
       {
         try {
           globaldefs.NameAndStringValue_T objectName[] = globaldefs.NamingAttributes_THelper.read (in);
           String nativeEMSName = in.read_string ();
           this.setNativeEMSName (objectName, nativeEMSName);
           out = $rh.createReply();
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>The userLabel is owned by the NMSes.  It is a string assigned by an NMS 
     * to an object. The difference between the userLabel and the NamingAttributes 
     * name is that the userLabel is an attribute of the objects that 
     * may be "set" by the NMS through well defined interfaces (setUserLabel).</p>
     *
     * <p>When an object is created by an NMS, the NMS specifies the userLabel for 
     * the object.</p>
     *
     * <p>When an object is created by the EMS, the EMS sets the userLabel to the 
     * nativeEMSName.</p>
     *
     * <p>Once an object is created, the userLabel may only be changed by an NMS 
     * through the setUserLabel operation.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName: Name of the object for 
     *  which to change the userLabel.
     * <br> string userLabel: New user label to assign to the object
     * <br> boolean enforceUniqueness: Specifies whether or not userLabel should 
     * be checked for uniqueness amongst objects of the same class within the EMS.  
     * If true, then the operation will fail if userLabel is already in use.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which 
     *  does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the userLabel can not be set for the 
     *  specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * <br>
     **/
       case 12:  // common/Common_I/setUserLabel
       {
         try {
           globaldefs.NameAndStringValue_T objectName[] = globaldefs.NamingAttributes_THelper.read (in);
           String userLabel = in.read_string ();
           boolean enforceUniqueness = in.read_boolean ();
           this.setUserLabel (objectName, userLabel, enforceUniqueness);
           out = $rh.createReply();
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /** 
     * <p>This service sets the owner attribute of the specified object.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName
     * <br> string owner
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
     *  that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the owner can not be set for the 
     *  specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
       case 13:  // common/Common_I/setOwner
       {
         try {
           globaldefs.NameAndStringValue_T objectName[] = globaldefs.NamingAttributes_THelper.read (in);
           String owner = in.read_string ();
           this.setOwner (objectName, owner);
           out = $rh.createReply();
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /** 
     * <p>This service retrieves the capabilities of the manager.
     * All non-specified capabilities are assumed to be unsupported.</p>
     *
     * <br> CapabilityList_T capabilities
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, and cannot determine the reason it could not comply, it may raise this exception. <br>
     **/
       case 14:  // common/Common_I/getCapabilities
       {
         try {
           common.CapabilityList_THolder capabilities = new common.CapabilityList_THolder ();
           this.getCapabilities (capabilities);
           out = $rh.createReply();
           common.CapabilityList_THelper.write (out, capabilities.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }


  /**
     * <p>This service sets the additional info attribute
     * of the object identified by objectName. This operation should be used
     * to set both vendor specific attributes as well as the attributes that
     * are formally defined in this interface specification. See <a 
     * href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     * Additional Information Usage</a> for further details.</p>
     *
     * <p>As an input only the list of parameters to be changed, removed, or
     * added shall be provided.  If an entry is to be removed, "-" shall
     * be specified as a value.  If a parameter is specified that is currently
     * not part of the additionalInfo attribute of the specified object
     * that parameter is added by the EMS with the specified value.
     * The EMS may reject removal and addition requests, however.</p>
     *
     * <p> The operation is best effort (except where specified otherwise for a 
     * particular parameter).  The output specifies the
     * values which were actually set.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName: the managed object
     * whose additional info parameters are intended to get modified
     *
     * <br> globaldefs::NVSList_T additionalInfo: list of parameters
     * to be changed, added, or removed (input), updated to provide the
     * actually changed or added parameters (output)
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal
     *  failure (see errorReason attribute of ProcessingFailureException())<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed,
     *  raised when an input parameter is syntactical incorrect and raised when a 
     *  parameter is identified as only "settable" using a "specific operation" in 
     *  the <a href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     *  Additional Information Usage</a> document<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
     *  that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when the communication to the managed
     *  element containing or hosting objectName is lost<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable 
     *  to execute the request because at least one of the parameters although 
     *  valid can not be set and that parameter is identified as "not best effort" 
     *  in the <a href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     *  Additional Information Usage</a> document)<br>
     * <br>
  
     **/
       case 15:  // common/Common_I/setAdditionalInfo
       {
         try {
           globaldefs.NameAndStringValue_T objectName[] = globaldefs.NamingAttributes_THelper.read (in);
           globaldefs.NVSList_THolder additionalInfo = new globaldefs.NVSList_THolder ();
           additionalInfo.value = globaldefs.NVSList_THelper.read (in);
           this.setAdditionalInfo (objectName, additionalInfo);
           out = $rh.createReply();
           globaldefs.NVSList_THelper.write (out, additionalInfo.value);
         } catch (globaldefs.ProcessingFailureException $ex) {
           out = $rh.createExceptionReply ();
           globaldefs.ProcessingFailureExceptionHelper.write (out, $ex);
         }
         break;
       }

       default:
         throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
    }

    return out;
  } // _invoke

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:mtnm.tmforum.org/protection/ProtectionMgr_I:1.0", 
    "IDL:mtnm.tmforum.org/common/Common_I:1.0"};

  public String[] _all_interfaces (org.omg.PortableServer.POA poa, byte[] objectId)
  {
    return (String[])__ids.clone ();
  }

  public ProtectionMgr_I _this() 
  {
    return ProtectionMgr_IHelper.narrow(
    super._this_object());
  }

  public ProtectionMgr_I _this(org.omg.CORBA.ORB orb) 
  {
    return ProtectionMgr_IHelper.narrow(
    super._this_object(orb));
  }


} // class ProtectionMgr_IPOA
