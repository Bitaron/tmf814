package protection;


/**
* protection/_ProtectionMgr_IStub.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from protection.idl
* Wednesday, June 15, 2016 7:24:41 PM COT
*/


/**
   * <p>The ProtectionMgr_I is used to gain access to protection groups and
   * their operations.</p>
   **/
public class _ProtectionMgr_IStub extends org.omg.CORBA.portable.ObjectImpl implements protection.ProtectionMgr_I
{


  /**
     * <p>This operation is used by the client to discover all the 
     * protection groups currently in operation for the managed
     * element.</p>
     *
     * <br>globaldefs::NamingAttributes_T meName:
     * the name of the managed element for which the request is made.
     * <br>unsigned long how_many: Maximum number of protection groups 
     * to report in the first batch.
     * <br>ProtectionGroupList_T pgList: First batch of protection groups.
     * <br>ProtectionGroupIterator_I pgIt: Iterator used to access the 
     * remaining PGs, if any.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when meName does not reference a 
     *  managedElement object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when meName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * <br>
     **/
  public void getAllProtectionGroups (globaldefs.NameAndStringValue_T[] meName, int how_many, protection.ProtectionGroupList_THolder pgList, protection.ProtectionGroupIterator_IHolder pgpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllProtectionGroups", true);
                globaldefs.NamingAttributes_THelper.write ($out, meName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                pgList.value = protection.ProtectionGroupList_THelper.read ($in);
                pgpIt.value = protection.ProtectionGroupIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllProtectionGroups (meName, how_many, pgList, pgpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllProtectionGroups


  /**
     * <p>This operation is used by the client to discover all the 
     * equipment protection groups currently in operation for the managed
     * element.</p>
     *
     * <br>globaldefs::NamingAttributes_T meName:
     * the name of the managed element for which the request is made.
     * <br>unsigned long how_many: Maximum number of equipment protection 
     * groups to report in the first batch.
     * <br>EProtectionGroupList_T epgpList: First batch of equipment protection 
     * groups.
     * <br>EProtectionGroupIterator_I epgpIt: Iterator used to access the 
     * remaining EPGs, if any.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when meName does not reference a 
     *  managedElement object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when meName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  public void getAllEProtectionGroups (globaldefs.NameAndStringValue_T[] meName, int how_many, protection.EProtectionGroupList_THolder epgpList, protection.EProtectionGroupIterator_IHolder epgpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllEProtectionGroups", true);
                globaldefs.NamingAttributes_THelper.write ($out, meName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                epgpList.value = protection.EProtectionGroupList_THelper.read ($in);
                epgpIt.value = protection.EProtectionGroupIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllEProtectionGroups (meName, how_many, epgpList, epgpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllEProtectionGroups


  /**
     * <p>This operation is used to get the current status of a 
     * protectionGroup. This service is needed so that even if a filter
     * is established, the NMS can query the status of a protection 
     * group.</p>
     *
     * <br>globaldefs::NamingAttributes_T protectionGroupName:
     * the name of the protection Group that the client is
     * interested in.
     * <br>protection::ProtectionGroup_T protectionGroup: the returned 
     * protection group.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a protection 
     *  group<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references a PG object that 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
  public void getProtectionGroup (globaldefs.NameAndStringValue_T[] pgName, protection.ProtectionGroup_THolder protectionGroup) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getProtectionGroup", true);
                globaldefs.NamingAttributes_THelper.write ($out, pgName);
                $in = _invoke ($out);
                protectionGroup.value = protection.ProtectionGroup_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getProtectionGroup (pgName, protectionGroup        );
            } finally {
                _releaseReply ($in);
            }
  } // getProtectionGroup


  /**
     * <p>This operation is used to get the current status of a 
     * Equipment Protection Group. This service is needed so that even if a 
     * filter is established, the NMS can query the status of a 
     * protection group.</p>
     *
     * <br>globaldefs::NamingAttributes_T ePGPname:
     * the name of the equipment protection group that the client is
     * interested in.
     * <br>protection::EProtectionGroup_T eProtectionGroup: the returned 
     * equipment protection group.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INVALID_INPUT - Raised when ePGPName does not reference an equipment  
     *  protection group<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when ePGPName references an object which 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  public void getEProtectionGroup (globaldefs.NameAndStringValue_T[] ePGPname, protection.EProtectionGroup_THolder eProtectionGroup) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getEProtectionGroup", true);
                globaldefs.NamingAttributes_THelper.write ($out, ePGPname);
                $in = _invoke ($out);
                eProtectionGroup.value = protection.EProtectionGroup_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getEProtectionGroup (ePGPname, eProtectionGroup        );
            } finally {
                _releaseReply ($in);
            }
  } // getEProtectionGroup


  /**
     * <p>This operation gets the list of names of CTPs that are configured to 
     * carry Non-preemptible Unprotected extra Traffic.  The result is independent 
     * of the current switch status.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     *
     * <br>globaldefs::NamingAttributes_T groupName:
     * Name of the protection group.
     * <br>unsigned long how_many:
     * Maximum number of CTPs to be returned in the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList:
     * The first batch of CTPs that have NUT turned on.
     * <br>globaldefs::NamingAttributesIterator_I nameIt:
     * The iterator used to retrieve the remaining CTPs that have NUT turned 
     * on.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a 
     *  protectionGroup object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators
     *  that the EMS can support has been reached.
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  public void getAllNUTTPNames (globaldefs.NameAndStringValue_T[] pgName, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllNUTTPNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, pgName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllNUTTPNames (pgName, how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllNUTTPNames


  /**
     * <p>This operation gets the list of names of CTPs that can carry preemptible 
     * extra traffic.  The result is independent of the current
     * switch status.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     *
     * <br>globaldefs::NamingAttributes_T groupName:
     * Name of the protection group.
     * <br>unsigned long how_many:
     * Maximum number of CTPs to be returned in the first batch.
     * <br>globaldefs::NamingAttributesList_T tpNameList:
     * The first batch of CTPs that can carry preemptible extra traffic.
     * <br>globaldefs::NamingAttributesIterator_I tpit:
     * The iterator used to retrieve the remaining CTPs that can carry 
     * preemptible extra traffic.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a 
     *  protectionGroup object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators
     *  that the EMS can support has been reached.
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  public void getAllPreemptibleTPNames (globaldefs.NameAndStringValue_T[] pgName, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllPreemptibleTPNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, pgName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllPreemptibleTPNames (pgName, how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllPreemptibleTPNames


  /**
     * <p>This operation gets the list of CTPs that can carry protected
     * traffic. The result is independent of the current
     * switch status.</p>
     * 
     * <br>globaldefs::NamingAttributes_T pgName:
     * Name of the protection group.
     * <br>unsigned long how_many:
     * Maximum number of CTPs to be returned in the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList:
     * The first batch of CTPs that can carry protected traffic.
     * <br>globaldefs::NamingAttributesIterator_I nameIt:
     * The iterator used to retrieve the remaining CTPs that can carry 
     * protected traffic.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when pgName does not reference a 
     *  protectionGroup object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached.
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  public void getAllProtectedTPNames (globaldefs.NameAndStringValue_T[] pgName, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllProtectedTPNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, pgName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllProtectedTPNames (pgName, how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllProtectedTPNames


  /**
     * <p>This service is used by the NMS to get the latest switch status
     * on a SNC or a MSP group.
     * <p>It should be noted that although the term MSP was chosen 
     * as the original specific protection scheme to which the related behaviour
     * applied was Multiplex Section Protection, the label is now more generally 
     * applied to any 1+1 or 1:N Trail protection scheme.</p> 
     *
     * <p>When used on the reliable CTP/FTP of an SNC, a single struct is returned 
     * and the group name is NULL. The switchToTP indicates the presently active
     * source of the traffic to the protectedTP.
     *
     * <p> When used on a 1+1 MSP, a single struct is provided with the 
     * relevant data.
     *
     * <p> When used on a 1:N MSP, a struct per worker TP is presented with
     * protectedTP being the worker TP Name and the switchToTP identifying
     * the present source of the traffic.
     *
     * <p> When used on a 2F BLSR, two structs are returned, one per TP. 
     * In a stable state, the protectedTP and the switchToTP are the same TP. 
     * In a switched state, the switchToTP is the same for both protectedTPs.
     *
     * <p> When used on a 4F BLSR, two structs are returned,
     * each one identifying a span with the protectedTP being the worker TP 
     * and the switchToTP identifying the present source of the ring traffic
     * for that span.
     *
     * <p>See <a href=../../../supportingDocumentation/SD1-34_protectionSwitch.pdf >SD1-34 
     * Protection Switch</a>
     * for more information.</p>
     *
     * <br>globaldefs::NamingAttributes_T reliableSinkCtpOrGroupName:
     * This is the CTP/FTP that is the output of a service selector in 
     * case of the SNC or the group name for which the switch data is 
     * being requested. The termination point name must be explicit (a 
     * generic endpoint specification may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>protection::SwitchDataList_T: The current protection switch status
     * of the CTP, FTP or PG provided.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when reliableSinkCtpOrGroupName does not 
     *  reference a reliable CTP nor FTP nor PG object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when reliableSinkCtpOrGroupName references 
     *  a CTP or FTP or PG or object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
    * <br>
     **/
  public void retrieveSwitchData (globaldefs.NameAndStringValue_T[] reliableSinkCtpOrGroupName, protection.SwitchDataList_THolder switchData) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("retrieveSwitchData", true);
                globaldefs.NamingAttributes_THelper.write ($out, reliableSinkCtpOrGroupName);
                $in = _invoke ($out);
                switchData.value = protection.SwitchDataList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                retrieveSwitchData (reliableSinkCtpOrGroupName, switchData        );
            } finally {
                _releaseReply ($in);
            }
  } // retrieveSwitchData


  /**
     * <p>This service is used by the NMS to get the latest switch status
     * on an equipment protection group.<br>
     *
     * For a retrieval of a revertive M:N group, N ESwitchData_T 
     * are returned as a result of retrieveESwitchData (one for 
     * each worker equipment instance).<br>
     * 
     * For a retrieval of a non-revertive M:N group, N ESwitchData_T 
     * are returned as a result of retrieveESwitchData (one for 
     * each active equipment instance).<br>
     * 
     * <br>globaldefs::NamingAttributes_T ePGPName:
     * This is the equipment protection group name for which 
     * the switch data is being requested.
     *       
     * <br>protection::ESwitchDataList_T: The current protection switch status
     * of the equipment protection group provided.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when ePGPName does not reference an equipment 
     *  object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when ePGPName references object which does
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * <br>
     **/
  public void retrieveESwitchData (globaldefs.NameAndStringValue_T[] ePGPName, protection.ESwitchDataList_THolder eSwitchDataList) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("retrieveESwitchData", true);
                globaldefs.NamingAttributes_THelper.write ($out, ePGPName);
                $in = _invoke ($out);
                eSwitchDataList.value = protection.ESwitchDataList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                retrieveESwitchData (ePGPName, eSwitchDataList        );
            } finally {
                _releaseReply ($in);
            }
  } // retrieveESwitchData


  /**
     * <p> This service is used to execute a protection switch. The protection
     * switch may be performed via a protection switch command, on a protection 
     * group or on a CTP/FTP involved in an 
     * SNCP. The NMS requests the EMS to move the traffic received from the fromTP
     * to the toTP.  The same command is used to clear all existing commands.</p>
     * 
     * <p>For 4-fiber SONET/SDH SPRINGS, the span switch is performed on the   
     * PGT_MSP_1_FOR_N protection group, and the ring switch on the 
     * PGT_4_FIBER_BLSR group.</p>
     * 
     * <p>See 
     * <a href=../../../supportingDocumentation/SD1-34_protectionSwitch.pdf >SD1-34 Protection Switch</a>
     * for more information.</p>
     *
     * <p>It should be noted that although the term MSP was chosen 
     * as the original specific protection scheme to which the related behaviour
     * applied was Multiplex Section Protection, the label is now more generally 
     * applied to any 1+1 or 1:N Trail protection scheme.</p>
     * <br>ProtectionCommand_T protectionCommand: The command to be performed
     * <br>globaldefs::NamingAttributes_T reliableSinkCtpOrGroupName:
     * This is the CTP/FTP that is the output of a service selector in 
     * case of the SNC or the group name for which the switch data is 
     * being requested. The termination point name must be explicit (a 
     * generic endpoint specification may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>globaldefs::NamingAttributes_T fromTp: The present source of
     * the traffic. The termination point name must be explicit (a generic 
     * endpoint specification may not be used in this case).
     * <br>globaldefs::NamingAttributes_T toTp:   The requested source of
     * the traffic after the command. The termination point name must be 
     * explicit (a generic endpoint specification may not be used in this 
     * case).
     * <br>protection::SwitchData_T switchData: The protection switch status
     * of the toTp provided after the execution of the command.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this 
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when reliableSinkCtpOrGroupName, fromTp, or 
     *  toTp do not reference objects of the correct type. Raised when the
     *  reliableSinkCtpOrGroupName, fromTp, or toTp reference objects of the 
     *  correct type, but that are invalid in the context of this operation<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when reliableSinkCtpOrGroupName references  
     *  a CTP, FTP or PG object that does not exist, or when fromTp or toTp 
     *  references a CTP/FTP object that does not exist <br>
     * EXCPT_UNABLE_TO_COMPLY - Raised if the EMS is unable to perform the 
     *  operation<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to the managed element is 
     *  lost<br>
     **/
  public void performProtectionCommand (protection.ProtectionCommand_T protectionCommand, globaldefs.NameAndStringValue_T[] reliableSinkCtpOrGroupName, globaldefs.NameAndStringValue_T[] fromTp, globaldefs.NameAndStringValue_T[] toTp, protection.SwitchData_THolder switchData) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("performProtectionCommand", true);
                protection.ProtectionCommand_THelper.write ($out, protectionCommand);
                globaldefs.NamingAttributes_THelper.write ($out, reliableSinkCtpOrGroupName);
                globaldefs.NamingAttributes_THelper.write ($out, fromTp);
                globaldefs.NamingAttributes_THelper.write ($out, toTp);
                $in = _invoke ($out);
                switchData.value = protection.SwitchData_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                performProtectionCommand (protectionCommand, reliableSinkCtpOrGroupName, fromTp, toTp, switchData        );
            } finally {
                _releaseReply ($in);
            }
  } // performProtectionCommand


  /**
     * <p>This service returns the names of the Protection Groups containing the given
     * PhysicalTerminationPoint.</p>
     *
     * <br>globaldefs::NamingAttributes_T pTPName:
     * The name of the PhysicalTerminationPoint.
     * <br>globaldefs::NamingAttributesList_T pgNameList:
     * The names of the containing ProtectionGroups.
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException:<br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
     * EXCPT_INVALID_INPUT - Raised when pTPName is syntactically incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when pTPName references a
     *  PhysicalTerminationPointTPPool object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to some ME is lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request,
     *  and cannot determine the reason it could not comply,
     *  it may raise this exception. <br>
     * 
     **/
  public void getContainingPGNames (globaldefs.NameAndStringValue_T[] pTPName, globaldefs.NamingAttributesList_THolder pgNameList) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainingPGNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, pTPName);
                $in = _invoke ($out);
                pgNameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainingPGNames (pTPName, pgNameList        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainingPGNames


  /**
     * <p>The nativeEMSName is owned by the EMS.  It represents how an EMS user 
     * addresses an object on the EMS GUI.  The EMS may or may not support 
     * changing this value.</p>
     *
     * <p>When an object is created by the EMS, the EMS selects the nativeEMSName 
     * for the object.</p>
     *
     * <p>When an object is created by an NMS, the NMS specifies the userLabel for  
     * the object. If the EMS supports setting of nativeEMSNames, the 
     * nativeEMSName should be set to the same value as the userLabel.  If the EMS 
     * does not support setting of nativeEMSNames, or if the nativeEMSName has 
     * constraints that the userLabel does not satisfy, the EMS selects the 
     * nativeEMSName for the object.</p>
     *
     * <p>After an object has been created, the nativeEMSName may be changed by 
     * the NMS, if the EMS supports this functionality, using the setNativeEMSName 
     * operation.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName
     * <br> string nativeEMSName
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which 
     *  does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the nativeEMSName can not be set for 
     *  the specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost
     * <br>
     **/
  public void setNativeEMSName (globaldefs.NameAndStringValue_T[] objectName, String nativeEMSName) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setNativeEMSName", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                $out.write_string (nativeEMSName);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setNativeEMSName (objectName, nativeEMSName        );
            } finally {
                _releaseReply ($in);
            }
  } // setNativeEMSName


  /**
     * <p>The userLabel is owned by the NMSes.  It is a string assigned by an NMS 
     * to an object. The difference between the userLabel and the NamingAttributes 
     * name is that the userLabel is an attribute of the objects that 
     * may be "set" by the NMS through well defined interfaces (setUserLabel).</p>
     *
     * <p>When an object is created by an NMS, the NMS specifies the userLabel for 
     * the object.</p>
     *
     * <p>When an object is created by the EMS, the EMS sets the userLabel to the 
     * nativeEMSName.</p>
     *
     * <p>Once an object is created, the userLabel may only be changed by an NMS 
     * through the setUserLabel operation.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName: Name of the object for 
     *  which to change the userLabel.
     * <br> string userLabel: New user label to assign to the object
     * <br> boolean enforceUniqueness: Specifies whether or not userLabel should 
     * be checked for uniqueness amongst objects of the same class within the EMS.  
     * If true, then the operation will fail if userLabel is already in use.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which 
     *  does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the userLabel can not be set for the 
     *  specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * <br>
     **/
  public void setUserLabel (globaldefs.NameAndStringValue_T[] objectName, String userLabel, boolean enforceUniqueness) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setUserLabel", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                $out.write_string (userLabel);
                $out.write_boolean (enforceUniqueness);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setUserLabel (objectName, userLabel, enforceUniqueness        );
            } finally {
                _releaseReply ($in);
            }
  } // setUserLabel


  /** 
     * <p>This service sets the owner attribute of the specified object.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName
     * <br> string owner
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
     *  that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the owner can not be set for the 
     *  specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
  public void setOwner (globaldefs.NameAndStringValue_T[] objectName, String owner) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setOwner", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                $out.write_string (owner);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setOwner (objectName, owner        );
            } finally {
                _releaseReply ($in);
            }
  } // setOwner


  /** 
     * <p>This service retrieves the capabilities of the manager.
     * All non-specified capabilities are assumed to be unsupported.</p>
     *
     * <br> CapabilityList_T capabilities
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, and cannot determine the reason it could not comply, it may raise this exception. <br>
     **/
  public void getCapabilities (common.CapabilityList_THolder capabilities) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getCapabilities", true);
                $in = _invoke ($out);
                capabilities.value = common.CapabilityList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getCapabilities (capabilities        );
            } finally {
                _releaseReply ($in);
            }
  } // getCapabilities


  /**
     * <p>This service sets the additional info attribute
     * of the object identified by objectName. This operation should be used
     * to set both vendor specific attributes as well as the attributes that
     * are formally defined in this interface specification. See <a 
     * href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     * Additional Information Usage</a> for further details.</p>
     *
     * <p>As an input only the list of parameters to be changed, removed, or
     * added shall be provided.  If an entry is to be removed, "-" shall
     * be specified as a value.  If a parameter is specified that is currently
     * not part of the additionalInfo attribute of the specified object
     * that parameter is added by the EMS with the specified value.
     * The EMS may reject removal and addition requests, however.</p>
     *
     * <p> The operation is best effort (except where specified otherwise for a 
     * particular parameter).  The output specifies the
     * values which were actually set.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName: the managed object
     * whose additional info parameters are intended to get modified
     *
     * <br> globaldefs::NVSList_T additionalInfo: list of parameters
     * to be changed, added, or removed (input), updated to provide the
     * actually changed or added parameters (output)
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal
     *  failure (see errorReason attribute of ProcessingFailureException())<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed,
     *  raised when an input parameter is syntactical incorrect and raised when a 
     *  parameter is identified as only "settable" using a "specific operation" in 
     *  the <a href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     *  Additional Information Usage</a> document<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
     *  that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when the communication to the managed
     *  element containing or hosting objectName is lost<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable 
     *  to execute the request because at least one of the parameters although 
     *  valid can not be set and that parameter is identified as "not best effort" 
     *  in the <a href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     *  Additional Information Usage</a> document)<br>
     * <br>
  
     **/
  public void setAdditionalInfo (globaldefs.NameAndStringValue_T[] objectName, globaldefs.NVSList_THolder additionalInfo) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setAdditionalInfo", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                globaldefs.NVSList_THelper.write ($out, additionalInfo.value);
                $in = _invoke ($out);
                additionalInfo.value = globaldefs.NVSList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setAdditionalInfo (objectName, additionalInfo        );
            } finally {
                _releaseReply ($in);
            }
  } // setAdditionalInfo

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:mtnm.tmforum.org/protection/ProtectionMgr_I:1.0", 
    "IDL:mtnm.tmforum.org/common/Common_I:1.0"};

  public String[] _ids ()
  {
    return (String[])__ids.clone ();
  }

  private void readObject (java.io.ObjectInputStream s) throws java.io.IOException
  {
     String str = s.readUTF ();
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     org.omg.CORBA.Object obj = orb.string_to_object (str);
     org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate ();
     _set_delegate (delegate);
   } finally {
     orb.destroy() ;
   }
  }

  private void writeObject (java.io.ObjectOutputStream s) throws java.io.IOException
  {
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     String str = orb.object_to_string (this);
     s.writeUTF (str);
   } finally {
     orb.destroy() ;
   }
  }
} // class _ProtectionMgr_IStub
