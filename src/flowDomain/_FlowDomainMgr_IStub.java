package flowDomain;


/**
* flowDomain/_FlowDomainMgr_IStub.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from flowDomain.idl
* Wednesday, June 15, 2016 7:24:36 PM COT
*/


/**
   * <p>The FlowDomainMgr_I is used to gain access to flow domains,
   * matrix flow domains, flow domain fragments and their operations.</p>
   *

   * <p>A handle to an instance of this interface is gained via the
   * emsSession::EmsSession_I::getManager() operation.</p>
   **/
public class _FlowDomainMgr_IStub extends org.omg.CORBA.portable.ObjectImpl implements flowDomain.FlowDomainMgr_I
{


  /**
     * <p>This method allows an NMS to request a list of the flow domains
     * that exist in the EMS.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. </p>
     *
     * unsigned long <b>how_many</b>:
     * <br>Maximum number of flow domains to return in the first batch.<br>
     *
     * FDList_T <b>flowDomains</b>:
     * <br>First batch of flow domains.<br>
     *
     * FDIterator_I <b>fdIt</b>:
     * <br>Iterator to retrieve the remaining flow domains.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * <br>
     **/
  public void getAllFlowDomains (int how_many, flowDomain.FDList_THolder flowDomains, flowDomain.FDIterator_IHolder fdIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllFlowDomains", true);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                flowDomains.value = flowDomain.FDList_THelper.read ($in);
                fdIt.value = flowDomain.FDIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllFlowDomains (how_many, flowDomains, fdIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllFlowDomains


  /**
     * <p>This operation returns the flow domain structures for the flow domains
     * whose userLabel is supplied as a parameter.<br>
     * The operation does not use an iterator, since the number of flow domains
     * returned is usually expected to be 1.
     * </p>
     *
     * string <b>userLabel</b>:
     * <br>The user label of the flow domains to retrieve.<br>
     *
     * FDList_T <b>flowDomains</b>:
     * <br>The list of identified flow domains. <br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * <br>
     **/
  public void getFlowDomainsByUserLabel (String userLabel, flowDomain.FDList_THolder flowDomains) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getFlowDomainsByUserLabel", true);
                $out.write_string (userLabel);
                $in = _invoke ($out);
                flowDomains.value = flowDomain.FDList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getFlowDomainsByUserLabel (userLabel, flowDomains        );
            } finally {
                _releaseReply ($in);
            }
  } // getFlowDomainsByUserLabel


  /**
     * <p>This service returns a flow domain given a flow domain name.</p>
     * 
     * globaldefs::NamingAttributes_T <b>fdName</b>:
     * <br>Name of the flow domain to retrieve.<br>
     *
     * FlowDomain_T <b>flowDomain</b>:
     * <br>Flow domain structure returned.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when fdName does not reference a 
     *  flow domain object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdName references a 
     *  flow domain object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
  
     * <br>
     **/
  public void getFlowDomain (globaldefs.NameAndStringValue_T[] fdName, flowDomain.FlowDomain_THolder flowDomain) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getFlowDomain", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdName);
                $in = _invoke ($out);
                flowDomain.value = FlowDomain_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getFlowDomain (fdName, flowDomain        );
            } finally {
                _releaseReply ($in);
            }
  } // getFlowDomain


  /**
     * <p>This operation returns the flow domain structure for the (single) flow domain
     * that the Matrix Flow Domain that is supplied as a parameter is associated to.<br>
     * </p>
     *
     * in globaldefs::NamingAttributes_T  <b>mfdName</b>:
     * <br>The name of MFD.<br>
     *
     * FlowDomain_T <b>flowDomain</b>:
     * <br>The flow domain that the Matrix Flow Domain is associated to. <br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when mfdName does not reference a 
     *  matrix flow domain object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when mfdName references a 
  
     *  matrix flow domain object that does not exist<br>
  
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAssociatingFD (globaldefs.NameAndStringValue_T[] mfdName, flowDomain.FlowDomain_THolder flowDomain) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAssociatingFD", true);
                globaldefs.NamingAttributes_THelper.write ($out, mfdName);
                $in = _invoke ($out);
                flowDomain.value = FlowDomain_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAssociatingFD (mfdName, flowDomain        );
            } finally {
                _releaseReply ($in);
            }
  } // getAssociatingFD


  /**
     * <p>This service returns the transmission parameters of a flow domain,
     * matrix flow domain, flow domain fragment or transmission descriptor, 
     * given the name of the object.
     * A set of groups of transmission parameters to be returned may be specified.</p>
     * 
     * globaldefs::NamingAttributes_T <b>name</b>:
     * <br>Name of the flow domain, matrix flow domain, flow domain fragment or transmission 
     * descriptor for which the transmission parameters shall be retrieved.<br>
     *
     * ParameterGroupsList_T <b>filter</b>:
     * <br>This filter allows to specify a set of parameter groups. Only transmission
     * parameters that belong to one of the groups specified are returned. See the
     * supporting document <a href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf > SD1-16_LayeredParameters.pdf</a> for a set of available transmission
     * parameters and their groupings. If an empty list is specified, all transmission
     * parameters are returned.<br>
     *
     * transmissionParameters::LayeredParameterList_T <b>transmissionParams</b>:
  
     * <br>A list or requested transmission parameters. For a flow domain fragment
     * only one layer is contained by the list.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when name does not reference a 
     *   valid object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when name references an 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getTransmissionParams (globaldefs.NameAndStringValue_T[] name, String[] filter, transmissionParameters.LayeredParameterList_THolder transmissionParams) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getTransmissionParams", true);
                globaldefs.NamingAttributes_THelper.write ($out, name);
                flowDomain.ParameterGroupsList_THelper.write ($out, filter);
                $in = _invoke ($out);
                transmissionParams.value = transmissionParameters.LayeredParameterList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getTransmissionParams (name, filter, transmissionParams        );
            } finally {
                _releaseReply ($in);
            }
  } // getTransmissionParams


  /**
     * <p>This service allows the NMS to request from the EMS the creation of a
     * flow domain given the parameters passed in the method. The NMS may specify
     * matrix flow domains or flow domain edge CPTPs to be associated with
     * the created flow domain.</p>
     *
     * FDCreateData_T <b>createData</b>:
     * <br>Structure describing the flow domain structure to be created.<br>
     *
     * globaldefs::NamingAttributesList_T <b>assignedCPTPs</b>:
     * <br>Identifies the list of assigned CPTPs to be associated as flow
     * domain edge CPTPs to the flow domain. This may be an empty list.
     * Associating CPTPs to the flow domain is done on a best effort basis. 
  
     * On method return the list contains the names of the CPTPs that could
     * not be associated with the flow domain. <br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
     * 
     * FlowDomain_T <b>theFD</b>:
     * <br>The new created FD. The EMS is responsible for guaranteeing
     * uniqueness of the name of the FD. The name may be specified by the
     * NMS in the createData. <br>
     *
     * string <b>errorReason</b>:
     * <br>In case a "best effort" parameter could not be set or a CPTP could
     * not be associated with the flow domain an indication of the fault reason
     * is provided by the EMS.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically 
     *  incorrect (e.g. field of createData is invalid).<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable to execute the
     *  request because at least one of the parameters although 
     *  valid cannot be set and that parameter is identified as 
     *  "not best effort" or when a CPTP is not assigned to one of
     *  the matrix flow domains specified in the createData or when one of the
     *  specified MFDs could not be associated. <br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when at least one of the specified CPTPs or
     *  MFDs does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * EXCPT_OBJECT_IN_USE - Raised if a specified matrix flow domain is already
     *  associated to an existing flow domain or if the flow domain name specified by the
     *  NMS is already assigned to an existing object.<br>
     * <br>
     **/
  public void createFlowDomain (flowDomain.FDCreateData_T createData, globaldefs.NamingAttributesList_THolder assignedCPTPs, subnetworkConnection.TPDataList_THolder tpsToModify, flowDomain.FlowDomain_THolder theFD, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("createFlowDomain", true);
                flowDomain.FDCreateData_THelper.write ($out, createData);
                globaldefs.NamingAttributesList_THelper.write ($out, assignedCPTPs.value);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                assignedCPTPs.value = globaldefs.NamingAttributesList_THelper.read ($in);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                theFD.value = FlowDomain_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                createFlowDomain (createData, assignedCPTPs, tpsToModify, theFD, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // createFlowDomain


  /**
     * <p>This service allows an NMS to request the deletion of a flow domain from
     * the EMS.</p>
     *
     * NamingAttributes_T <b>fdName</b>:
     * <br>The name of the flow domain to be deleted.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
  
     *
     * string <b>errorReason</b>:
     * <br>Specifies the fault reason if any.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactical 
     *  incorrect, i.e. fdName does not refer to a flow domain object <br>
     * EXCPT_OBJECT_IN_USE - Raised when the flow domain contains at least one
     *  flow domain fragment <br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdName references an object that does 
  
     *  not exist <br>
     * EXCPT_UNABLE_TO_COMPLY - Raised if an associated flow domain edge CPTP
     *  or matrix flow domain could not be de-associated<br> 
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * <br>
     **/
  public void deleteFlowDomain (globaldefs.NameAndStringValue_T[] fdName, subnetworkConnection.TPDataList_THolder tpsToModify, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("deleteFlowDomain", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdName);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                deleteFlowDomain (fdName, tpsToModify, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // deleteFlowDomain


  /**
     * <p>The NMS invokes the modifyFlowDomain service to request from the EMS to modify an 
     * existing flow domain as specified by the parameters passed in the method.</p>
     *
  
     * globaldefs::NamingAttributes_T <b>fdName</b>:
  
     * <br>The name of the flow domain to modify.<br>
     *
     * FDModifyData_T <b>fdModifyData</b>:
     * <br>Structure describing how the flow domain should be modified. If the
     * flow domain contains already the required information nothing is done on
     * the EMS and the method returns successfully.<br>
     *
     * string <b> failedAttributes</b> :
     * The list of attributes that could not be modified.<br>
     *
     * FlowDomain_T <b>modifiedFD</b>:
     * <br>The modified flow domain.<br>
     *
     * string <b>errorReason</b>:
     * <br>Specifies the fault reason if any.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically 
     *  incorrect (e.g. field of fdModifyData is invalid).<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdName references an object that does 
     *  not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable 
     *  to execute the request because at least one of the parameters although 
     *  valid cannot be set. <br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation, which prevents the creation of an MFD or CPTP.<br>
     * <br>
     **/
  public void modifyFlowDomain (globaldefs.NameAndStringValue_T[] fdName, flowDomain.FDModifyData_T fdModifyData, flowDomain.FlowDomain_THolder modifiedFD, org.omg.CORBA.StringHolder failedAttributes, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("modifyFlowDomain", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdName);
                flowDomain.FDModifyData_THelper.write ($out, fdModifyData);
                $in = _invoke ($out);
                modifiedFD.value = FlowDomain_THelper.read ($in);
                failedAttributes.value = $in.read_string ();
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                modifyFlowDomain (fdName, fdModifyData, modifiedFD, failedAttributes, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // modifyFlowDomain


  /**
     *<p>This service allows an NMS to request from the EMS the association
     * of one or more matrix flow domains with a flow domain.</p>
     *
     * globaldefs::NamingAttributes_T <b>fdName</b>:
     * <br>The name of the flow domain to be modified.<br>
     *
     * globaldefs::NamingAttributesList_T <b>mfdNames</b>:
     * <br>The names of the matrix flow domains to be associated with the flow domain.
     * If the list is empty nothing is done on the EMS and the method returns
     * success.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
     *
     * string <b>errorReason</b>:
     * <br>Specifies the fault reason if any.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactical 
     *  incorrect (e.g. fdName does not refer to a flow domain object)<br>
     * EXCPT_OBJECT_IN_USE - Raised when a matrix flow domain is already
     *  associated with another flow domain <br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdName or one of the mfdNames
     *  reference an object that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when a matrix flow domain could not be
     *  associated<br> 
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * <br>
     **/
  public void associateMFDsWithFlowDomain (globaldefs.NameAndStringValue_T[] fdName, globaldefs.NameAndStringValue_T[][] mfdNames, subnetworkConnection.TPDataList_THolder tpsToModify, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("associateMFDsWithFlowDomain", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdName);
                globaldefs.NamingAttributesList_THelper.write ($out, mfdNames);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                associateMFDsWithFlowDomain (fdName, mfdNames, tpsToModify, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // associateMFDsWithFlowDomain


  /**
     *<p>This service allows an NMS to request from the EMS the de-association
     * of one or more matrix flow domains from a flow domain.</p>
     *
     * globaldefs::NamingAttributes_T <b>fdName</b>:
     * <br>The name of the flow domain to be modified.<br>
     *
     * globaldefs::NamingAttributesList_T <b>mfdNames</b>:
     * <br>The names of the matrix flow domains to be de-associated from the flow
     * domain. If the list is empty nothing is done on the EMS and the method returns
     * success.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
     *
     * string <b>errorReason</b>:
     * <br>Specifies the fault reason if any.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
  
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactical 
     *  incorrect (e.g. fdName does not refer to a flow domain object)<br>
     * EXCPT_OBJECT_IN_USE - Raised when a matrix flow domain to be de-associated
     *  carries traffic<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdName or one of the mfdNames
     *  reference an object that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when a matrix flow domain could not be
     *  de-associated, e.g. because it is not associated with the flow domain, or if
     *  a flow domain edge CPTP contained by one of the MFDs to be de-associated could
     *  not be de-associated<br> 
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * <br>
     **/
  public void deAssociateMFDsFromFlowDomain (globaldefs.NameAndStringValue_T[] fdName, globaldefs.NameAndStringValue_T[][] mfdNames, subnetworkConnection.TPDataList_THolder tpsToModify, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("deAssociateMFDsFromFlowDomain", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdName);
                globaldefs.NamingAttributesList_THelper.write ($out, mfdNames);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                deAssociateMFDsFromFlowDomain (fdName, mfdNames, tpsToModify, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // deAssociateMFDsFromFlowDomain


  /**
     *<p>This service allows an NMS to request from the EMS the association
     * of one or more CPTPs with a flow domain as flow domain edge CPTPs.</p>
     *
     * globaldefs::NamingAttributes_T <b>fdName</b>:
     * <br>The name of the flow domain to be modified.<br>
     *
     * globaldefs::NamingAttributesList_T <b>cptpNames</b>:
     * <br>The names of the CPTPs to be associated with the flow domain. 
     * If the list is empty nothing is done on the EMS and the method returns
     * success.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
     *
     * string <b>errorReason</b>:
     * <br>In case a "best effort" parameter could not be set or a CPTP could
     * not be associated with the flow domain an indication of the fault reason
     * is provided by the EMS.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically
     *  incorrect (e.g. fdName does not refer to a flow domain object)<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdName or one of the tpNames
     *  references an object that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when a CPTP could not be associated,
     *  e.g. because it is not assigned to one of the matrix flow domains
     *  associated with the flow domain<br> 
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed
     *  element involved in this operation<br>
     * <br>
     **/
  public void associateCPTPsWithFlowDomain (globaldefs.NameAndStringValue_T[] fdName, globaldefs.NameAndStringValue_T[][] cptpNames, subnetworkConnection.TPDataList_THolder tpsToModify, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("associateCPTPsWithFlowDomain", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdName);
                globaldefs.NamingAttributesList_THelper.write ($out, cptpNames);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                associateCPTPsWithFlowDomain (fdName, cptpNames, tpsToModify, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // associateCPTPsWithFlowDomain


  /**
     *<p>This service allows an NMS to request from the EMS the de-association
     * of one or more CPTPs from a flow domain.</p>
     *
     * globaldefs::NamingAttributes_T <b>fdName</b>:
     * <br>The name of the flow domain to be modified.<br>
     *
     * globaldefs::NamingAttributesList_T <b>cptpNames</b>:
     * <br>The names of the CPTPs to be de-associated from the flow domain. If
     * the list is empty nothing is done on the EMS and the method returns
     * success.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
     *
     * string <b>errorReason</b>:
     * <br>In case a "best effort" parameter could not be set or a CPTP could
     * not be associated with the flow domain an indication of the fault reason
     * is provided by the EMS.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically 
     *  incorrect (e.g. fdName does not refer to a flow domain object)<br>
     * EXCPT_OBJECT_IN_USE - Raised when a CPTP to be de-associated carries
     *  traffic, i.e. is connected to a flow domain fragment<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdName or one of the cptpNames
     *  reference an object that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when a CPTP could not be
     *  de-associated, e.g. because it is not associated with the flow domain<br> 
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * <br>
     **/
  public void deAssociateCPTPsFromFlowDomain (globaldefs.NameAndStringValue_T[] fdName, globaldefs.NameAndStringValue_T[][] tpNames, subnetworkConnection.TPDataList_THolder tpsToModify, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("deAssociateCPTPsFromFlowDomain", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdName);
                globaldefs.NamingAttributesList_THelper.write ($out, tpNames);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                deAssociateCPTPsFromFlowDomain (fdName, tpNames, tpsToModify, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // deAssociateCPTPsFromFlowDomain


  /**
     * <p>This service allows an NMS to request a list of matrix flow domains
     * that are associated
     * with a specified transmission descriptor or flow domain.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. </p>
     *
     * globaldefs::NamingAttributes_T <b>tmdOrFdName</b>:
     * <br>Name of the transmission descriptor
     * or flow domain.<br>
     *
     * unsigned long <b>how_many</b>:
     * <br>Maximum number of matrix flow domains to return in the first batch.<br>
     *
     * MFDList_T <b>mfds</b>:
     * <br>First batch of matrix flow domains.<br>
     *
     * MFDIterator_I <b>mfdIt</b>:
  
     * <br>Iterator to retrieve the remaining matrix flow domains.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when tmdOrFdName does not reference a 
     *  transmission descriptor or flow domain object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tmdOrFdName references an object that 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when the maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllAssociatedMFDs (globaldefs.NameAndStringValue_T[] tmdOrFdName, int how_many, flowDomain.MFDList_THolder mfds, flowDomain.MFDIterator_IHolder mfdIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllAssociatedMFDs", true);
                globaldefs.NamingAttributes_THelper.write ($out, tmdOrFdName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                mfds.value = flowDomain.MFDList_THelper.read ($in);
                mfdIt.value = flowDomain.MFDIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllAssociatedMFDs (tmdOrFdName, how_many, mfds, mfdIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllAssociatedMFDs


  /**
     * <p>This service allows an NMS to request a list of matrix flow domains
     * that are supported by a specified managed element or supported
     * with a specified equipment.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. </p>
     *
     * globaldefs::NamingAttributes_T <b>holderName</b>:
     * <br>Name of the managed element or equipment.<br>
     *
     * unsigned long <b>how_many</b>:
     * <br>Maximum number of matrix flow domains to return in the first batch.<br>
     *
     * MFDList_T <b>mfds</b>:
     * <br>First batch of matrix flow domains.<br>
     *
     * MFDIterator_I <b>mfdIt</b>:
     * <br>Iterator to retrieve the remaining matrix flow domains.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when holderName does not reference a 
     *  managed element or equipment object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when holderName references an object that 
  
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when the maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllSupportedMFDs (globaldefs.NameAndStringValue_T[] holderName, int how_many, flowDomain.MFDList_THolder mfds, flowDomain.MFDIterator_IHolder mfdIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllSupportedMFDs", true);
                globaldefs.NamingAttributes_THelper.write ($out, holderName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                mfds.value = flowDomain.MFDList_THelper.read ($in);
                mfdIt.value = flowDomain.MFDIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllSupportedMFDs (holderName, how_many, mfds, mfdIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllSupportedMFDs


  /**
     * <p>This service returns a matrix flow domain given a matrix flow domain
     * name.</p>
     * 
     * globaldefs::NamingAttributes_T <b>mfdName</b>:
     * <br>Name of the matrix flow domain to retrieve.<br>
     *
     * MatrixFlowDomain_T <b>mfd</b>:
     * <br>Matrix flow domain structure returned.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when mfdName does not reference a 
     *  matrix flow domain object<br>    
     * EXCPT_ENTITY_NOT_FOUND - Raised when mfdName references a 
     *  matrix flow domain object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getMFD (globaldefs.NameAndStringValue_T[] mfdName, flowDomain.MatrixFlowDomain_THolder mfd) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getMFD", true);
                globaldefs.NamingAttributes_THelper.write ($out, mfdName);
                $in = _invoke ($out);
                mfd.value = flowDomain.MatrixFlowDomain_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getMFD (mfdName, mfd        );
            } finally {
                _releaseReply ($in);
            }
  } // getMFD


  /**
     * <p>This service returns the matrix flow domain to which is assigned
     * a given "CPTP" termination point.</p>
     * 
     * globaldefs::NamingAttributes_T <b>cptpName</b>:
     * <br>Name of the "CPTP" termination point to which the MFD is assigned.<br>
     *
     * MatrixFlowDomain_T <b>mfd</b>:
     * <br>Matrix flow domain structure returned.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when cptpName does not reference a 
  
     *  "CPTP" termination point <br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when mfdName references a 
     *  termination point object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAssigningMFD (globaldefs.NameAndStringValue_T[] cptpName, flowDomain.MatrixFlowDomain_THolder mfd) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAssigningMFD", true);
                globaldefs.NamingAttributes_THelper.write ($out, cptpName);
                $in = _invoke ($out);
                mfd.value = flowDomain.MatrixFlowDomain_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAssigningMFD (cptpName, mfd        );
            } finally {
                _releaseReply ($in);
            }
  } // getAssigningMFD


  /**
  
     * <p>Using this service the NMS requests from the EMS the creation of a
     * matrix flow domain given the parameters passed in the method. The NMS
     * must specify CPTPs to be associated with the created matrix flow domain.
     * </p>
     *
  
     * MFDCreateData_T <b>createData</b>:
     * <br>Structure describing the matrix flow domain structure to be created.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
     *
     * MatrixFlowDomain_T <b>theMFD</b>:
     * <br>The new created matrix flow domain. The EMS is responsible for guaranteeing
     * uniqueness of the name of the matrix flow domain. The name may be specified
     * by the NMS in the createData. <br>
     *
     * string <b>errorReason</b>:
     * <br> Specifies the creation error(s) if any. <br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically 
     *  incorrect (e.g. field of createData is invalid).<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable to execute the
     *  request because at least one of the parameters although valid cannot be set
     *  or if an unassigned CPTP could not be assigned <br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * EXCPT_OBJECT_IN_USE - Raised if a specified CPTP is already associated to
     *  an existing matrix flow domain or if the name for the matrix flow domain as
     *  specified by the NMS is already assigned to an existing object.<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to the managed element
     *  that shall contain the MFD<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when one of the provided TPs  
     *  does not exist<br>
     * <br>
     **/
  public void createMFD (flowDomain.MFDCreateData_T createData, subnetworkConnection.TPDataList_THolder tpsToModify, flowDomain.MatrixFlowDomain_THolder theMFD, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("createMFD", true);
                flowDomain.MFDCreateData_THelper.write ($out, createData);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                theMFD.value = flowDomain.MatrixFlowDomain_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                createMFD (createData, tpsToModify, theMFD, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // createMFD


  /**
     * <p>This service allows an NMS to request the deletion of a matrix flow domain
     * from the EMS.</p>
     *
     * NamingAttributes_T <b>mfdName</b>:
     * <br>The name of the matrix flow domain to be deleted.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
     *
  
     * string <b>errorReason</b>:
     * <br>In case a "best effort" parameter could not be set 
     * an indication of the fault reason
     * is provided by the EMS.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
  
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically
     *  incorrect (e.g. mfdName does not refer to a matrix flow domain object)<br>
     * EXCPT_OBJECT_IN_USE - Raised when the matrix flow domain is associated with a flow domain<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when mfdName references an object that does 
     *  not exist<br>
     * EXCPT_ACCESS_DENIED - Raised if the matrix flow domain is fixed<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to the managed element
     *  containing the MFD<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void deleteMFD (globaldefs.NameAndStringValue_T[] mfdName, subnetworkConnection.TPDataList_THolder tpsToModify, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("deleteMFD", true);
                globaldefs.NamingAttributes_THelper.write ($out, mfdName);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                deleteMFD (mfdName, tpsToModify, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // deleteMFD


  /**
     * <p>This method allows a modification of a matrix flow domain as requested by
     * the NMS.</p>
     *
     * globaldefs::NamingAttributes_T <b>mfdName</b>:
     * <br>The name of the matrix flow domain to modify.<br>
     *
     * MFDModifyData_T <b>mfdModifyData</b>:
     * <br>Structure describing how the matrix flow domain shall be modified. This
     * parameter contains the parameters that are not best effort. If the modification
     * of one of the parameters fails an exception will be thrown.<br>
     *
     * string <b> failedAttributes</b> :
     * The list of attributes that could not be modified.<br>
     *
     * MatrixFlowDomain_T <b>newMFD</b>:
     * <br>The modified matrix flow domain.<br>
     *
     * string <b>errorReason</b>:
     * <br>In case a "best effort" parameter could not be set the fault reason
     * is provided by the EMS.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically 
     *  incorrect (e.g. field of mfdModifyData is invalid).<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when mfdName references an object that does 
     *  not exist<br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation.<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void modifyMFD (globaldefs.NameAndStringValue_T[] mfdName, flowDomain.MFDModifyData_T mfdModifyData, flowDomain.MatrixFlowDomain_THolder newMFD, org.omg.CORBA.StringHolder failedAttributes, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("modifyMFD", true);
                globaldefs.NamingAttributes_THelper.write ($out, mfdName);
                flowDomain.MFDModifyData_THelper.write ($out, mfdModifyData);
                $in = _invoke ($out);
                newMFD.value = flowDomain.MatrixFlowDomain_THelper.read ($in);
                failedAttributes.value = $in.read_string ();
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                modifyMFD (mfdName, mfdModifyData, newMFD, failedAttributes, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // modifyMFD


  /**
     *<p>This service allows an NMS to request from the EMS the assignment
     * of one or more "CPTP" TPs to a matrix flow domain.</p>
     *
     * globaldefs::NamingAttributes_T <b>mfdName</b>:
     * <br>The name of the matrix flow domain to be modified.<br>
  
     *
     * globaldefs::NamingAttributesList_T <b>tpNames</b>:
     * <br>The names of the CPTPs to be assigned to the matrix flow domain.
     * If the list is empty or all CPTPs are already assigned to the matrix flow domain
     * nothing is done on the EMS and the method returns success.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
     *
     * string <b>errorReason</b>:
     * <br>Specifies the fault reason if any.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically 
     *  incorrect (e.g. mfdName does not refer to a matrix flow domain object)<br>
     * EXCPT_OBJECT_IN_USE - Raised when a CPTP is already assigned
     *  to another matrix flow domain<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when mfdName or one of the tpNames
     *  reference an object that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when a CPTP could not be
     *  assigned<br> 
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to the managed element
     *  containing the MFD<br>
     * <br>
     **/
  public void assignCPTPsToMFD (globaldefs.NameAndStringValue_T[] mfdName, globaldefs.NameAndStringValue_T[][] tpNames, subnetworkConnection.TPDataList_THolder tpsToModify, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("assignCPTPsToMFD", true);
                globaldefs.NamingAttributes_THelper.write ($out, mfdName);
                globaldefs.NamingAttributesList_THelper.write ($out, tpNames);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                assignCPTPsToMFD (mfdName, tpNames, tpsToModify, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // assignCPTPsToMFD


  /**
     *<p>This service allows an NMS to request from the EMS to unassign
     * one or more CPTPs from a matrix flow domain.</p>
     *
     * globaldefs::NamingAttributes_T <b>mfdName</b>:
     * <br>The name of the matrix flow domain to be modified.<br>
     *
     * globaldefs::NamingAttributesList_T <b>tpNames</b>:
     * <br>The names of the CPTPs to be unassigned from the matrix flow domain.
     * If no CPTP has been specified, the method returns success.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
     *
     * string <b>errorReason</b>:
     * <br>Specifies the fault reason if any.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically
     *  incorrect (e.g. mfdName does not refer to a matrix flow domain object)<br>
     * EXCPT_OBJECT_IN_USE - Raised when a CPTP to be unassigned carries
     *  traffic or is connected to a call<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when mfdName or one of the tpNames
     *  references an object that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when a CPTP could not be
     *  unassigned, e.g. because it is not assigned to the matrix flow domain<br> 
     * EXCPT_NOT_IN_VALID_STATE - Raised when at least one of the specified CPTPs
     *  is in the "unassigned" "Port TP role state"<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to the managed element
     *  that contains the matrix flow domain<br>
     * <br>
     **/
  public void unassignCPTPsFromMFD (globaldefs.NameAndStringValue_T[] mfdName, globaldefs.NameAndStringValue_T[][] tpNames, subnetworkConnection.TPDataList_THolder tpsToModify, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("unassignCPTPsFromMFD", true);
                globaldefs.NamingAttributes_THelper.write ($out, mfdName);
                globaldefs.NamingAttributesList_THelper.write ($out, tpNames);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                unassignCPTPsFromMFD (mfdName, tpNames, tpsToModify, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // unassignCPTPsFromMFD


  /**
     * <p>Using this service the NMS requests from the EMS the creation of a
     * FTP given the parameters passed in the method. 
     * </p>
     *
     * FTPCreateData_T <b>createData</b>:
     * <br>Structure describing the floating termination point to be created.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: A list of TPs and parameters to apply, 
     * updated to provide the resulting parameters. 
     *
     * <br> Applying transmission parameters is best-effort (where not stated 
     * otherwise) and the resulting values of the transmission parameters are 
     * provided in the updated tpsToModify parameter. If the parameter is "not 
     * best effort" then the whole operation will be rejected and the appropriate 
     * exception thrown (see exceptions below).</p>
     *
     * <br> This parameter may be used by the NMS to determine
     * the number of server layer CTPs to create for the specified FTP.
     * An empty list means that the number of server layer CTPs 
  
     * is determined by the EMS. <br>
     * 
     *
     * TerminationPoint_T <b>theFTP</b>:
     * <br>The new floating termination point. The EMS is responsible for guaranteeing
     * uniqueness of the name of the FTP. The name may be specified
     * by the NMS in the createData. <br>
     *
     * string <b>errorReason</b>:
     * <br> Specifies the creation error(s) if any.
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically 
  
     *  incorrect (e.g. field of createData is invalid).<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS (or NE) does not support explicit creation 
     * of CPTPs. <br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when the specified equipment does not exist.
     * <br>
     * EXCPT_CAPACITY_EXCEEDED - Raised when The Equipment does not have the resources 
     * (e.g., not enough overall back-plane bandwidth, not enough usable timeslots, etc.)<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to the managed element
     *  that shall contain the FTP<br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * EXCPT_OBJECT_IN_USE - Raised when the object identified in the request is
     *  currently in use<br>
     * <br>
     **/
  public void createFTP (flowDomain.FTPCreateData_T createData, subnetworkConnection.TPDataList_THolder tpsToModify, terminationPoint.TerminationPoint_THolder theFTP, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("createFTP", true);
                flowDomain.FTPCreateData_THelper.write ($out, createData);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                theFTP.value = terminationPoint.TerminationPoint_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                createFTP (createData, tpsToModify, theFTP, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // createFTP


  /**
     * <p>This service allows an NMS to request the deletion of a floating termination point.</p>
     *
     * NamingAttributes_T <b>tpName</b>:
     * <br>The name of the termination point to be deleted.<br>
     *
     * TPDataList_T <b>tpsToModify</b>: in: The list of TPs with associated 
     * parameters to be applied. out: The list of TPs with associated 
     * applied parameters. <br>
     *
     * string <b>errorReason</b>:
     * <br>In case the operation completes without exception, 
     * but some error occurred or part of the request could not be filled,
     * an indication of the fault reason
     * is provided by the EMS.<br>
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactical 
     *  incorrect, i.e. tpName does not refer to a "CPTP" termination point object <br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references an object that does 
     *  not exist <br>
     * EXCPT_OBJECT_IN_USE - Raised when the CPTP is an ELL endpoint.
     *  <br>
     * EXCPT_UNABLE_TO_COMPLY - Raised if the TP is is not deleteable.
     *  <br>  
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * <br>
     **/
  public void deleteFTP (globaldefs.NameAndStringValue_T[] ftpName, subnetworkConnection.TPDataList_THolder tpsToModify, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("deleteFTP", true);
                globaldefs.NamingAttributes_THelper.write ($out, ftpName);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                deleteFTP (ftpName, tpsToModify, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // deleteFTP


  /**
     * <p>This service returns the structures of all CPTPs, 
     * or all flow domain edge CPTPs, or all flow domain internal CPTPs,
        *  associated with a 
     * flow domain. </p>
     * 
     * globaldefs::NamingAttributes_T <b>fdName</b>:
     * <br>Name of the flow domain whose associated CPTPs shall be returned. <br>
     *
     * CPTP_Role_T	<b>cptpRole</b>:
        * <br> Which CPTPs to return : flow domain edge, flow domain internal, or all CPTPs.<br>
     *
     * unsigned long <b>how_many</b>:
     * <br>Maximum number of CPTPs to return in the first batch.<br>
     *
     * terminationPoint::TerminationPointList_T <b>cptpList</b>:
     * <br>First batch of CPTPs.<br>
     *
  
     * terminationPoint::TerminationPointIterator_I <b>cptpIt</b>:
     * <br>Iterator to retrieve the remaining CPTPs.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when fdName does not reference a
     *  flow domain object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdName references an object that 
     *  does not exist<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllCPTPs (globaldefs.NameAndStringValue_T[] fdName, flowDomain.CPTP_Role_T cptpRole, int how_many, terminationPoint.TerminationPointList_THolder cptpList, terminationPoint.TerminationPointIterator_IHolder cptpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllCPTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdName);
                flowDomain.CPTP_Role_THelper.write ($out, cptpRole);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                cptpList.value = terminationPoint.TerminationPointList_THelper.read ($in);
                cptpIt.value = terminationPoint.TerminationPointIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllCPTPs (fdName, cptpRole, how_many, cptpList, cptpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllCPTPs


  /**
     * <p>This service returns the structures of all CPTPs assigned to 
     * a matrix flow domain. </p>
     * 
     * globaldefs::NamingAttributes_T <b>mfdName</b>:
     * <br>Name of the matrix flow domain whose assigned CPTPs shall be returned. <br>
     *
     * unsigned long <b>how_many</b>:
     * <br>Maximum number of CPTPs to return in the first batch.<br>
     *
     * terminationPoint::TerminationPointList_T <b>cptpList</b>:
     * <br>First batch of CPTPs.<br>
     *
     * terminationPoint::TerminationPointIterator_I <b>cptpIt</b>:
     * <br>Iterator to retrieve the remaining CPTPs.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when mfdName does not reference a
     *  matrix flow domain object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when mfdName references an object that 
     *  does not exist<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllAssignedCPTPs (globaldefs.NameAndStringValue_T[] mfdName, int how_many, terminationPoint.TerminationPointList_THolder cptpList, terminationPoint.TerminationPointIterator_IHolder cptpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllAssignedCPTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, mfdName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                cptpList.value = terminationPoint.TerminationPointList_THelper.read ($in);
                cptpIt.value = terminationPoint.TerminationPointIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllAssignedCPTPs (mfdName, how_many, cptpList, cptpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllAssignedCPTPs


  /**
     * <p>This service returns the structures of all "CPTP" TPs that are potentially 
     * able to be assigned to a matrix flow domain </p>
     * 
     * <p> Potentially means: The CPTPs are on the same equipment or same rack with 
     * backplane connectivity as the NMS specified MFD. It is irrelevant whether the CPTPs 
     * are already assigned to an MFD or not. </p>
     * 
     * globaldefs::NamingAttributes_T <b>mfdName</b>:
     * <br>Name of the matrix flow domain whose potential CPTPs shall be returned.<br>
     *
     * unsigned long <b>how_many</b>:
     * <br>Maximum number of CPTPs to return in the first batch.<br>
     *
     * terminationPoint::TerminationPointList_T <b>cptpList</b>:
     * <br>First batch of CPTPs.<br>
     *
     * terminationPoint::TerminationPointIterator_I <b>cptpIt</b>:
     * <br>Iterator to retrieve the remaining CPTPs.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
  
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when mfdName does not reference a
     *  matrix flow domain object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when mfdName references an object that 
     *  does not exist<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
  
     *  that the EMS can support has been reached<br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllAssignableCPTPs (globaldefs.NameAndStringValue_T[] mfdName, int how_many, terminationPoint.TerminationPointList_THolder cptpList, terminationPoint.TerminationPointIterator_IHolder cptpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllAssignableCPTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, mfdName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                cptpList.value = terminationPoint.TerminationPointList_THelper.read ($in);
                cptpIt.value = terminationPoint.TerminationPointIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllAssignableCPTPs (mfdName, how_many, cptpList, cptpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllAssignableCPTPs


  /**
     * <p>This allows an NMS to request a list of flow domain fragments for the
     * specified flow domain at the specified connectivityRates.
     * </p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator.</p>
     *
     * globaldefs::NamingAttributes_T <b>fdName</b>: 
     * <br>Name of the flow domain.<br>
     *
     * transmissionParameters::LayerRateList_T <b>connectivityRateList</b>:
     * <br>List of rates of the flow domain fragments to be reported.
     * If an empty list is specified, then all flow domain fragments of all 
     * rates are to be reported.<br>
     *
     * unsigned long <b>how_many</b>:
     * <br>Maximum number of flow domai fragments to be reported in the first
     * batch.<br>
     *
     * flowDomainFragment::FDFrList_T <b>fdfrList</b>:
     * <br>First batch of flow domain fragments.<br>
     *
     * flowDomainFragment::FDFrIterator_I <b>fdfrIt</b>:
     * <br>Iterator to retrieve the remaining flow domain fragment.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when fdName does not reference a
     *  flow domain object or connectivityRateList contains undefined 
     *  values<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdName references an object that 
     *  does not exist<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllFDFrs (globaldefs.NameAndStringValue_T[] fdName, int how_many, short[] connectivityRateList, flowDomainFragment.FDFrList_THolder fdfrList, flowDomainFragment.FDFrIterator_IHolder fdfrIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllFDFrs", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdName);
                $out.write_ulong (how_many);
                transmissionParameters.LayerRateList_THelper.write ($out, connectivityRateList);
                $in = _invoke ($out);
                fdfrList.value = flowDomainFragment.FDFrList_THelper.read ($in);
                fdfrIt.value = flowDomainFragment.FDFrIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllFDFrs (fdName, how_many, connectivityRateList, fdfrList, fdfrIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllFDFrs


  /**
     * <p>This service allows the NMS to request from the EMS the flow domain
     * fragments that are connected to a specified flow point or CPTP. In case
     * of a flow point as input parameter not more than one flow domain fragment
     * will be returned.</p>
     *
     * globaldefs::NamingAttributes_T <b>tpName</b>:
     * <br>The name of the flow point or CPTP for which the connected flow
  
     * domain fragments shall be returned.<br>
     *
     * unsigned long <b>how_many</b>:
     * <br>Maximum number of flow domain fragments to be reported in the first
     * batch.<br>    *
     * flowDomainFragment::FDFrList_T <b>fdfrList</b>:
     * <br>First batch of flow domain fragments.<br>
     *
     * flowDomainFragment::FDFrIterator_I <b>fdfrIt</b>:
     * <br>Iterator to retrieve the remaining flow domain fragments.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when tpName does not reference a flow point
     *  or CPTP<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised tpName references an object that does not
  
     *  exist<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
  
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getFDFrsWithTP (globaldefs.NameAndStringValue_T[] cptpName, int how_many, flowDomainFragment.FDFrList_THolder fdfrList, flowDomainFragment.FDFrIterator_IHolder fdfrIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getFDFrsWithTP", true);
                globaldefs.NamingAttributes_THelper.write ($out, cptpName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                fdfrList.value = flowDomainFragment.FDFrList_THelper.read ($in);
                fdfrIt.value = flowDomainFragment.FDFrIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getFDFrsWithTP (cptpName, how_many, fdfrList, fdfrIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getFDFrsWithTP


  /**
     * <p>This operation returns the flow domain fragment structures for the
     * flow domain fragments whose userLabel is supplied as a parameter.<br>
  
     * The operation does not use an iterator, since the number of flow domain    * fragments returned is usually expected to be 1.
  
     * </p>
     *
     * in string <b>userLabel</b>:
     * <br>The user label of the flow domain fragments to retrieve.<br>
     *
     * FDFrList_T <b>fdfrs</b>:
     * <br>The list of identified flow domain fragments. <br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
    * <br>
     **/
  public void getFDFrsByUserLabel (String userLabel, flowDomainFragment.FDFrList_THolder fdfrs) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getFDFrsByUserLabel", true);
                $out.write_string (userLabel);
                $in = _invoke ($out);
                fdfrs.value = flowDomainFragment.FDFrList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getFDFrsByUserLabel (userLabel, fdfrs        );
            } finally {
                _releaseReply ($in);
            }
  } // getFDFrsByUserLabel


  /**
     * <p>This operation returns the flow domain fragment structure 
     * for the flow domain fragment whose name is supplied as a parameter.</p>
     *
     * globaldefs::NamingAttributes_T <b>fdfrName</b>:
     * <br>The name of the flow domain fragment to retrieve.<br>
     *
     * flowDomainFragment::FlowDomainFragment_T <b>fdfr</b>:
     * <br>The flow domain fragment structure retrieved.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     * failure<br>
     * EXCPT_INVALID_INPUT - Raised when fdfrName does not reference a 
     *  flow domain fragment object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdfrName references a flow domain
     *  fragment object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
    * <br>
     **/
  public void getFDFr (globaldefs.NameAndStringValue_T[] fdfrName, flowDomainFragment.FlowDomainFragment_THolder fdfr) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getFDFr", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdfrName);
                $in = _invoke ($out);
                fdfr.value = flowDomainFragment.FlowDomainFragment_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getFDFr (fdfrName, fdfr        );
            } finally {
                _releaseReply ($in);
            }
  } // getFDFr


  /**
     * <p>The NMS invokes the createAndActivateFDFr service to request the EMS to create
     * and activate a flow domain fragment given the parameters passed in the method.</p>
     *
     * flowDomainFragment::FDFrCreateData_T <b>createData</b>:
     * <br>Structure describing the FDFr structure to be created. Setting of
     * connectionless parameters is best effort (except where specified otherwise 
     * for a particular parameter).<br>
     *
     * ConnectivityRequirement_T <b>connectivityRequirement</b>:
     * <br> For a "connectivity-aware" EMS, this parameter shall identify 
     * the requested operation mode in case not all FPs have potential connectivity 
     * to one another. If the EMS is not connectivity-aware, this parameter is ignored.
     * <br>
     *
     * globaldefs::NamingAttributesList_T <b>aEnd</b>:
     * <br> A list of of CPTP names that delimit the FDFr and characterize 
     * its edges (entrance and/or exit points). As a result of creating the FDFr,
     * FPs are created as clients of the FD Edge CPTPs. 
     * <br> In case of a unidirectional 
     * FDFr this attribute contains the list of <b>source</b> FD Edge CPTPs. 
     * <br> In case of a 
     * bidirectional FDFr this attribute may be combined with the zEnd TPs 
     * attribute to obtain all the FD Edge CPTPs that are associated to the 
     * FDFr. 
     * <br> (N.B. For a bidirectional point to point FDFr it is suggested, but not 
     * mandatory, to put one TP in the aEnd and one in the zEnd, as with SNCs and 
     * TLs. For a multipoint FDFr, or a point-to-point FDFr that may be expanded 
     * to multipoint, it is suggested to put all the TPs in the aEnd.) 
     * <br>
     *
     * globaldefs::NamingAttributesList_T <b>zEnd</b>:
     * <br> In case of a unidirectional FDFr this attribute contains the list of 
     * <b>sink</b> FD Edge CPTPs that delimit the FDFr and characterize its edges
     *  (exit points). 
     * <br> As a result of creating the FDFr, FPs are created as 
     * clients of the FD Edge CPTPs. 
     * <br> In case of a bidirectional FDFr this attribute 
     * may be combined with the aEnd TPs attribute to obtain all the FD Edge CPTPs 
     * that are associated to the FDFr.
     * <br>
     *
     * globaldefs::NamingAttributesList_T <b>internalTPs</b>:
     * <br>A (possibly empty) list of internal CPTP names that must be included 
     * in the route of the FDFr. As a result of creating the FDFr, 
     * FPs are created as clients of the internal CPTPs.
     * <br>
     *
     * flowDomainFragment::MatrixFlowDomainFragmentList_T <b>mfdfrs</b>:
     * <br> An optional (possibly empty) list of MFDFrs that make up the route 
     * of the FDFr. This attribute may be omitted if the FDFr is routed by the network. 
     * As a result of creating the FDFr, MFDFrs are created in the various MFDs.
     * <br>
     *
     * subnetworkConnection::TPDataList_T <b>tpsToModify</b>: 
     * <br>A list of TPs and parameters to apply. On method return the list is 
     * updated to provide the resulting parameters. The list may refer to
     * flow points that are being created during the createAndActivateFDFr request
     * or to the containing CPTPs. <br>
     * 
     * flowDomainFragment::FlowDomainFragment_T <b>theFDFr</b>:
     * <br>The new created and activated flow domain fragment. The EMS is responsible
  
     * for guaranteeing uniqueness of the name of the flow domain fragment. <br>
     *
     * globaldefs::NamingAttributesList_T <b>notConnectableCPTPList</b>:
     * <br>The list of Connectionless Port Termination Points that could not 
     * be connected. <br> 
     *
     * globaldefs::NamingAttributesList_T <b>parameterProblemsTPList</b>:
     * <br>The list of Connectionless Port Termination Points and Flow Points FPs
     * for which only best-effort transmission parameters could not be set. <br>
     *
     * string <b>errorReason</b>:
  
     * <br>In case a "best effort" parameter could not be set or a flow point could not
     * be connected an indication of the fault reason is provided by the EMS.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically 
     *  incorrect (e.g. field of createData is invalid).<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when one of the provided CPTPs does not exist.
     * <br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met; the specified user label is currently being used.<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable 
     *  to execute the request because of one of the following conditions:<ul> 
     * <li> at least one of the parameters although 
     *  valid cannot be set and that parameter is identified as 
     *  "not best effort"; </li>
     *  <li> the name specified by the NMS exists already in the EMS;</li>
     *  <li> The FP total connectivity constraint is not met;</li>
     * <li> Unrecognized mapping criteria;</li>
  
     * <li> Frames map to more than one FDFr;</li>
     * <li> The FDFr would have less than two FPs.</li>
     * </ul>  <br>
     * EXCPT_NE_COMM_LOSS - Raised in case of Communications failure between the EMS 
  
     * and the ME(s). 
     * <br>
     * EXCPT_NOT_IN_VALID_STATE - Raised when the state of the specified object is such 
     * that the EMS cannot perform the request.. 
     * <br>
     * EXCPT_TP_INVALID_ENDPOINT - Raised when the specified TP does not exist or cannot be created. <br>
     * <br>
     **/
  public void createAndActivateFDFr (flowDomainFragment.FDFrCreateData_T createData, flowDomain.ConnectivityRequirement_T connectivityRequirement, globaldefs.NameAndStringValue_T[][] aEnd, globaldefs.NameAndStringValue_T[][] zEnd, globaldefs.NamingAttributesList_THolder internalTPs, flowDomainFragment.MatrixFlowDomainFragmentList_THolder mfdfrs, subnetworkConnection.TPDataList_THolder tpsToModify, flowDomainFragment.FlowDomainFragment_THolder theFDFr, globaldefs.NamingAttributesList_THolder notConnectableCPTPList, globaldefs.NamingAttributesList_THolder parameterProblemsTPList, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("createAndActivateFDFr", true);
                flowDomainFragment.FDFrCreateData_THelper.write ($out, createData);
                flowDomain.ConnectivityRequirement_THelper.write ($out, connectivityRequirement);
                globaldefs.NamingAttributesList_THelper.write ($out, aEnd);
                globaldefs.NamingAttributesList_THelper.write ($out, zEnd);
                globaldefs.NamingAttributesList_THelper.write ($out, internalTPs.value);
                flowDomainFragment.MatrixFlowDomainFragmentList_THelper.write ($out, mfdfrs.value);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                internalTPs.value = globaldefs.NamingAttributesList_THelper.read ($in);
                mfdfrs.value = flowDomainFragment.MatrixFlowDomainFragmentList_THelper.read ($in);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                theFDFr.value = flowDomainFragment.FlowDomainFragment_THelper.read ($in);
                notConnectableCPTPList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                parameterProblemsTPList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                createAndActivateFDFr (createData, connectivityRequirement, aEnd, zEnd, internalTPs, mfdfrs, tpsToModify, theFDFr, notConnectableCPTPList, parameterProblemsTPList, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // createAndActivateFDFr


  /**
     *<p>This service allows an NMS to request the deactivation and deletion of a flow
     * domain fragment from a flow domain.</p>
     *
  
     * <br>globaldefs::NamingAttributes_T <b>fdfrName</b>:
     * <br>The name of the flow domain fragment to be deactivated and deleted.<br>
     *
  
     * <br>subnetworkConnection::TPDataList_T <b>tpsToModify</b>: 
     * <br>A list of TPs and parameters to apply. On method return the list is 
     * updated to provide the resulting parameters. The list may refer only to
     * TPs that take part in the flow domain fragment deletion process. 
     * <br>
     *
     * <br>flowDomainFragment::FlowDomainFragment_T <b>theFDFr</b>: 
     * <br>The deactivated and deleted flow domain fragment.<br>
     * 
     * string <b>errorReason</b>:
     * <br>Specifies the fault reason if any.<br>
     
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactical 
     *  incorrect (e.g. fdfrName does not refer to an FDFr object)<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdfrName references an object that does 
     *  not exist<br>
     * EXCPT_ACCESS_DENIED - Raised if the EMS does not allow the NMS to delete the
     *  flow domain fragment, e.g. if the flow domain fragment is fixed <br>
     * EXCPT_NE_COMM_LOSS - Raised when communcation is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void deactivateAndDeleteFDFr (globaldefs.NameAndStringValue_T[] fdfrName, subnetworkConnection.TPDataList_THolder tpsToModify, flowDomainFragment.FlowDomainFragment_THolder theFDFr, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("deactivateAndDeleteFDFr", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdfrName);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                theFDFr.value = flowDomainFragment.FlowDomainFragment_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                deactivateAndDeleteFDFr (fdfrName, tpsToModify, theFDFr, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // deactivateAndDeleteFDFr


  /**
     * <p>The NMS invokes the modifyFDFr service to request the EMS to modify an 
     * existing flow domain fragment as specified by the parameters passed in the
     * method.</p>
     *
     * globaldefs::NamingAttributes_T <b>fdfrName</b>:
     * <br>The name of the flow domain fragment to modify.<br>
     *
     * flowDomainFragment::FDFrModifyData_T <b>fdfrModifyData</b>:
     * <br>Structure describing how the flow domain fragment should be modified.
     * Modification of connectionless parameters is best effort (except where 
     * specified otherwise for a particular parameter).<br>
     *
     * ConnectivityRequirement_T <b>connectivityRequirement</b>:
     * <br> For a "connectivity-aware" EMS, this parameter shall identify 
     * the requested operation mode in case not all FPs have potential connectivity 
     * to one another. 
     * <br> This parameter is only significant if the fdfrModifyData parameter
     * contains flow points to be added or removed, otherwise it shall be ignored
     * by the EMS. If the EMS is not connectivity-aware, this parameter is also ignored.
     * <br>
     *
     * subnetworkConnection::TPDataList_T <b>tpsToModify</b>: 
     * <br>A list of TPs and parameters to apply. On method return the list is 
     * updated to provide the resulting parameters. The list may refer to
     * flow points or to the containing CPTPs. <br>
     *
     * globaldefs::NamingAttributesList_T <b>failedTPList</b>:
     * <br> The list of Connectionless Port Termination Points or Flow Points
     * (requested in the fdfrModifyData parameter) 
     * that could not be added or could not be removed, 
     * whichever was requested.<br>
     *
     * globaldefs::NamingAttributesList_T <b>parameterProblemsTPList</b>:
     * <br> The list of Connectionless Port Termination Points and Flow Points FPs
     *  for which only best-effort transmission parameters could not be set. <br>
     *
     * flowDomainFragment::FlowDomainFragment_T <b>newFDFr</b>:
     * <br>The modified flow domain fragment.<br>
     *
     * string <b>errorReason</b>:
     * <br>In case a "best effort" parameter could not be set an indication of the 
     * fault reason is provided by the EMS.<br>
     *
     * <b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when any input parameter is syntactically 
     *  incorrect (e.g. field of fdfrModifyData is invalid).<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdfrName references an object that does 
     *  not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable 
     *  to execute the request because at least one of the parameters although 
     *  valid cannot be set and that parameter is identified as 
     *  "not best effort" or if the EMS cannot meet the GradesOfImpact requested by
     *  the NMS <br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * EXCPT_ACCESS_DENIED - Raised if the EMS does not allow the NMS to modify the
     *  flow domain fragment, e.g. if the flow domain fragment is fixed <br>
     * EXCPT_NOT_IN_VALID_STATE - Raised when at least one of the specified CPTPs
     *  is in the "unassigned" "Port TP role state"<br>
     * <br>
     **/
  public void modifyFDFr (globaldefs.NameAndStringValue_T[] fdfrName, flowDomainFragment.FDFrModifyData_T fdfrModifyData, flowDomain.ConnectivityRequirement_T connectivityRequirement, subnetworkConnection.TPDataList_THolder tpsToModify, globaldefs.NamingAttributesList_THolder failedTPList, globaldefs.NamingAttributesList_THolder parameterProblemsTPList, flowDomainFragment.FlowDomainFragment_THolder newFDFr, org.omg.CORBA.StringHolder errorReason) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("modifyFDFr", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdfrName);
                flowDomainFragment.FDFrModifyData_THelper.write ($out, fdfrModifyData);
                flowDomain.ConnectivityRequirement_THelper.write ($out, connectivityRequirement);
                subnetworkConnection.TPDataList_THelper.write ($out, tpsToModify.value);
                $in = _invoke ($out);
                tpsToModify.value = subnetworkConnection.TPDataList_THelper.read ($in);
                failedTPList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                parameterProblemsTPList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                newFDFr.value = flowDomainFragment.FlowDomainFragment_THelper.read ($in);
                errorReason.value = $in.read_string ();
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                modifyFDFr (fdfrName, fdfrModifyData, connectivityRequirement, tpsToModify, failedTPList, parameterProblemsTPList, newFDFr, errorReason        );
            } finally {
                _releaseReply ($in);
            }
  } // modifyFDFr


  /**
     * <p> 
     * This service returns a list of TopologicalLinks which are terminated at the Flow Domain whose name is 
     * passed as a parameter.  </p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf > SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <p>For details on how topologicalLinks should be modelled see
     * <a href=../../../supportingDocumentation/SD1-18_layers.pdf >
     * SD1-18 Functional Modelling Concepts</a>.</p>
     * 
     * <br>globaldefs::NamingAttributes_T flowDomainName: The name of the 
     * Flow Domain.
     * <br>unsigned long how_many: Maximum number of topological links to 
     * return in the first batch.
     * <br>topologicalLink::TopologicalLinkList_T topoList: First batch of 
     * topological links.
     * <br>topologicalLink::TopologicalLinkIterator_I topoIt: Iterator to 
     * retrieve the remaining
     * topological links.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when flowDomainName does not reference a 
     *  FlowDomain object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when flowDomainName references an object that 
  
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllTopologicalLinksOfFD (globaldefs.NameAndStringValue_T[] flowDomainName, int how_many, topologicalLink.TopologicalLinkList_THolder topoList, topologicalLink.TopologicalLinkIterator_IHolder topoIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllTopologicalLinksOfFD", true);
                globaldefs.NamingAttributes_THelper.write ($out, flowDomainName);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                topoList.value = topologicalLink.TopologicalLinkList_THelper.read ($in);
                topoIt.value = topologicalLink.TopologicalLinkIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllTopologicalLinksOfFD (flowDomainName, how_many, topoList, topoIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllTopologicalLinksOfFD


  /**
     * <p>This service returns the route for the FDFr whose name is specified 
     * as a parameter. 
     * It is only used for systems where the route is provisioned by the NMS
     * (e.g., it is not useful for Ethernet networks using GVRP).</p>
     *
     * <br>globaldefs::NamingAttributes_T fdfrName: The name of the FDFr.
     * <br> flowDomainFragment::FDFrRoute_T route: The route of the FDFr.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the entire request is not supported 
     * by the EMS or the request with the specified input parameters 
     * is not supported. <br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when fdfrName does not reference a 
     *  FDFr object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when fdfrName references an FDFr object that 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communication is lost to a managed element
     *  involved in this operation<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getFDFrRoute (globaldefs.NameAndStringValue_T[] fdfrName, flowDomainFragment.FDFrRoute_THolder route) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getFDFrRoute", true);
                globaldefs.NamingAttributes_THelper.write ($out, fdfrName);
                $in = _invoke ($out);
                route.value = flowDomainFragment.FDFrRoute_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getFDFrRoute (fdfrName, route        );
            } finally {
                _releaseReply ($in);
            }
  } // getFDFrRoute


  /**
     * <p>The nativeEMSName is owned by the EMS.  It represents how an EMS user 
     * addresses an object on the EMS GUI.  The EMS may or may not support 
     * changing this value.</p>
     *
     * <p>When an object is created by the EMS, the EMS selects the nativeEMSName 
     * for the object.</p>
     *
     * <p>When an object is created by an NMS, the NMS specifies the userLabel for  
     * the object. If the EMS supports setting of nativeEMSNames, the 
     * nativeEMSName should be set to the same value as the userLabel.  If the EMS 
     * does not support setting of nativeEMSNames, or if the nativeEMSName has 
     * constraints that the userLabel does not satisfy, the EMS selects the 
     * nativeEMSName for the object.</p>
     *
     * <p>After an object has been created, the nativeEMSName may be changed by 
     * the NMS, if the EMS supports this functionality, using the setNativeEMSName 
     * operation.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName
     * <br> string nativeEMSName
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which 
     *  does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the nativeEMSName can not be set for 
     *  the specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost
     * <br>
     **/
  public void setNativeEMSName (globaldefs.NameAndStringValue_T[] objectName, String nativeEMSName) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setNativeEMSName", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                $out.write_string (nativeEMSName);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setNativeEMSName (objectName, nativeEMSName        );
            } finally {
                _releaseReply ($in);
            }
  } // setNativeEMSName


  /**
     * <p>The userLabel is owned by the NMSes.  It is a string assigned by an NMS 
     * to an object. The difference between the userLabel and the NamingAttributes 
     * name is that the userLabel is an attribute of the objects that 
     * may be "set" by the NMS through well defined interfaces (setUserLabel).</p>
     *
     * <p>When an object is created by an NMS, the NMS specifies the userLabel for 
     * the object.</p>
     *
     * <p>When an object is created by the EMS, the EMS sets the userLabel to the 
     * nativeEMSName.</p>
     *
     * <p>Once an object is created, the userLabel may only be changed by an NMS 
     * through the setUserLabel operation.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName: Name of the object for 
     *  which to change the userLabel.
     * <br> string userLabel: New user label to assign to the object
     * <br> boolean enforceUniqueness: Specifies whether or not userLabel should 
     * be checked for uniqueness amongst objects of the same class within the EMS.  
     * If true, then the operation will fail if userLabel is already in use.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which 
     *  does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the userLabel can not be set for the 
     *  specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * <br>
     **/
  public void setUserLabel (globaldefs.NameAndStringValue_T[] objectName, String userLabel, boolean enforceUniqueness) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setUserLabel", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                $out.write_string (userLabel);
                $out.write_boolean (enforceUniqueness);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setUserLabel (objectName, userLabel, enforceUniqueness        );
            } finally {
                _releaseReply ($in);
            }
  } // setUserLabel


  /** 
     * <p>This service sets the owner attribute of the specified object.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName
     * <br> string owner
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
     *  that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the owner can not be set for the 
     *  specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
  public void setOwner (globaldefs.NameAndStringValue_T[] objectName, String owner) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setOwner", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                $out.write_string (owner);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setOwner (objectName, owner        );
            } finally {
                _releaseReply ($in);
            }
  } // setOwner


  /** 
     * <p>This service retrieves the capabilities of the manager.
     * All non-specified capabilities are assumed to be unsupported.</p>
     *
     * <br> CapabilityList_T capabilities
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, and cannot determine the reason it could not comply, it may raise this exception. <br>
     **/
  public void getCapabilities (common.CapabilityList_THolder capabilities) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getCapabilities", true);
                $in = _invoke ($out);
                capabilities.value = common.CapabilityList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getCapabilities (capabilities        );
            } finally {
                _releaseReply ($in);
            }
  } // getCapabilities


  /**
     * <p>This service sets the additional info attribute
     * of the object identified by objectName. This operation should be used
     * to set both vendor specific attributes as well as the attributes that
     * are formally defined in this interface specification. See <a 
     * href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     * Additional Information Usage</a> for further details.</p>
     *
     * <p>As an input only the list of parameters to be changed, removed, or
     * added shall be provided.  If an entry is to be removed, "-" shall
     * be specified as a value.  If a parameter is specified that is currently
     * not part of the additionalInfo attribute of the specified object
     * that parameter is added by the EMS with the specified value.
     * The EMS may reject removal and addition requests, however.</p>
     *
     * <p> The operation is best effort (except where specified otherwise for a 
     * particular parameter).  The output specifies the
     * values which were actually set.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName: the managed object
     * whose additional info parameters are intended to get modified
     *
     * <br> globaldefs::NVSList_T additionalInfo: list of parameters
     * to be changed, added, or removed (input), updated to provide the
     * actually changed or added parameters (output)
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal
     *  failure (see errorReason attribute of ProcessingFailureException())<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed,
     *  raised when an input parameter is syntactical incorrect and raised when a 
     *  parameter is identified as only "settable" using a "specific operation" in 
     *  the <a href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     *  Additional Information Usage</a> document<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
     *  that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when the communication to the managed
     *  element containing or hosting objectName is lost<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable 
     *  to execute the request because at least one of the parameters although 
     *  valid can not be set and that parameter is identified as "not best effort" 
     *  in the <a href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     *  Additional Information Usage</a> document)<br>
     * <br>
  
     **/
  public void setAdditionalInfo (globaldefs.NameAndStringValue_T[] objectName, globaldefs.NVSList_THolder additionalInfo) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setAdditionalInfo", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                globaldefs.NVSList_THelper.write ($out, additionalInfo.value);
                $in = _invoke ($out);
                additionalInfo.value = globaldefs.NVSList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setAdditionalInfo (objectName, additionalInfo        );
            } finally {
                _releaseReply ($in);
            }
  } // setAdditionalInfo

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:mtnm.tmforum.org/flowDomain/FlowDomainMgr_I:1.0", 
    "IDL:mtnm.tmforum.org/common/Common_I:1.0"};

  public String[] _ids ()
  {
    return (String[])__ids.clone ();
  }

  private void readObject (java.io.ObjectInputStream s) throws java.io.IOException
  {
     String str = s.readUTF ();
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     org.omg.CORBA.Object obj = orb.string_to_object (str);
     org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate ();
     _set_delegate (delegate);
   } finally {
     orb.destroy() ;
   }
  }

  private void writeObject (java.io.ObjectOutputStream s) throws java.io.IOException
  {
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     String str = orb.object_to_string (this);
     s.writeUTF (str);
   } finally {
     orb.destroy() ;
   }
  }
} // class _FlowDomainMgr_IStub
