package managedElementManager;


/**
* managedElementManager/_ManagedElementMgr_IStub.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from managedElementManager.idl
* Wednesday, June 15, 2016 7:24:38 PM COT
*/


/**
   * <p>The managedElementManager is used to gain access to operations
   * which deal with managed elements and termination points.</p>
   *
   * <p>A handle to an instance of this interface is gained via the
   * emsSessionFactory::EmsSession_I::getManager() operation in Manager.</p>
   **/
public class _ManagedElementMgr_IStub extends org.omg.CORBA.portable.ObjectImpl implements managedElementManager.ManagedElementMgr_I
{


  /**
     * <p>This allows an NMS to request details of all of the Managed Elements 
     * that are under the control of this ManagedElementMgr_I.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>unsigned long how_many: Maximum number of MEs to report in the first 
     * batch.
     * <br> managedElement::ManagedElementList_T meList: First batch of MEs.
     * <br>managedElement::ManagedElementIterator_I meIt: Iterator to retrieve 
     * the remaining MEs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached.<br>
     * <br>
     **/
  public void getAllManagedElements (int how_many, managedElement.ManagedElementList_THolder meList, managedElement.ManagedElementIterator_IHolder meIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllManagedElements", true);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                meList.value = managedElement.ManagedElementList_THelper.read ($in);
                meIt.value = managedElement.ManagedElementIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllManagedElements (how_many, meList, meIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllManagedElements


  /**
     * <p>This operation has exactly the same behaviour as 
     * getAllManagedElements(), but
     * instead of returning the entire object structures, this operation returns 
     * their names.</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>unsigned long how_many: Maximum number of ME names to return in the 
     * first batch.
     * <br>globaldefs::NamingAttributesList_T nameList: First batch of ME 
     * names.
     * <br>globaldefs::NamingAttributesListIterator_I nameIt: Iterator to 
     * retrieve remaining ME names.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * As for getAllManagedElements()
     **/
  public void getAllManagedElementNames (int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllManagedElementNames", true);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllManagedElementNames (how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllManagedElementNames


  /** 
     * <p>This service returns the list of subnetwork names that the  
     * Managed Element supplied as an input parameter belongs to.<p>
     * <br>globaldefs::NamingAttributes managedElementName: The name of the 
     * managed element for which to retrieve the containing subnetwork names. 
     * <br>globaldefs::NamingAttributesList_T subnetNames: The names of the 
     * subnetworks this NE belongs to.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a 
     *  managed element object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
  public void getContainingSubnetworkNames (globaldefs.NameAndStringValue_T[] managedElementName, globaldefs.NamingAttributesList_THolder subnetNames) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainingSubnetworkNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                $in = _invoke ($out);
                subnetNames.value = globaldefs.NamingAttributesList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainingSubnetworkNames (managedElementName, subnetNames        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainingSubnetworkNames


  /**
     * <p>Note: This interface has been enhanced in version 3 to return both PTPs 
     * and FTPs (maximising inter-version compatibility). Two new operations have 
     * been added to getAllPTPsWithoutFTPs() and getAllFTPs() to allow more 
     * selective retrieval. </p>
     *
     * <p>This allows an NMS to request all of the PTPs and FTPs on the specified  
     * Managed Element, that contain one or more of the NMS-specified PTP/FTP 
     * layer rates, and that are capable of supporting one or more of the NMS-
     * specified connection layer rates.
     * If there are no PTPs/FTPs that match the layer constraints, an empty 
     * list is returned. A PTP/FTP will be returned regardless
     * of connectivity to other managed elements and regardless of position
     * in the subnetwork (both edgepoints of the subnetwork and the PTPs/FTPs
     * that are internal to the subnetwork are reported).</p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
     * Managed Element for which to retrieve PTPs/FTPs.
     * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of 
     * PTP/FTP layer rates for which the PTPs/FTPs are to be fetched. A PTP/FTP 
     * must contain at least one of the layer rates specified to be reported.  If 
     * the list is empty then all PTPs/FTPs (of all rates)are returned.
     * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
     * of connection layer rates for which the PTPs/FTPs are to be fetched. A 
     * PTP/FTP must support connections for at least one of the
     * layer rates specified to be reported.  If the list is empty then all 
     * PTPs/FTPs (for all connection rates) are returned.
     * <br>unsigned long how_many: Maximum number of PTPs/FTPs to report in the 
     * first batch.
     * <br>terminationPoint::TerminationPointList_T tpList: First batch of 
     * PTPs/FTPs.
     * <br>terminationPoint::TerminationPointIterator_I tpIt: Iterator to 
     * retrieve remaining PTPs/FTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a 
     *  managed element object, or tpLayerRateList or connectionLayerRateList 
     *  contain undefined rates<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * <br>
     **/
  public void getAllPTPs (globaldefs.NameAndStringValue_T[] managedElementName, short[] tpLayerRateList, short[] connectionLayerRateList, int how_many, terminationPoint.TerminationPointList_THolder tpList, terminationPoint.TerminationPointIterator_IHolder tpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllPTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                transmissionParameters.LayerRateList_THelper.write ($out, tpLayerRateList);
                transmissionParameters.LayerRateList_THelper.write ($out, connectionLayerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                tpList.value = terminationPoint.TerminationPointList_THelper.read ($in);
                tpIt.value = terminationPoint.TerminationPointIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllPTPs (managedElementName, tpLayerRateList, connectionLayerRateList, how_many, tpList, tpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllPTPs


  /**
     * <p>Note: This interface has been added in version 3 to return PTPs 
     * only. It allows more selective retrieval than the modified 
     * getAllPTPs() which now returns PTPs and FTPs. </p>
     * <p>This operation has exactly the same behaviour as 
     * getAllPTPs() but
     * instead of returning both PTPs and FTPs it returns solely PTPs</p>
     *
     * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
     * Managed Element.
     * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of PTP 
     *  layer rates for which the PTPs are to be fetched. A PTP must contain at 
     *  least one of the layer rates specified to be reported.  If the list is 
     *  empty then PTPs of all rates are returned.
     * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
     *  of connection layer rates for which the PTPs are to be fetched. A PTP must 
     *  support connections for at least one of the
     *  layer rates specified to be reported.  If the list is empty then PTPs for 
     *  all connection rates are returned.
     * <br>unsigned long how_many: Maximum number of PTPs to return in the 
     * first batch.
     * <br>terminationPoint::TerminationPointList_T tpList: First batch of 
     * PTPs.
     * <br>terminationPoint::TerminationPointIterator_I tpIt: Iterator to 
     * retrieve remaining PTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br> 
     * As for getAllPTPs().
     **/
  public void getAllPTPsWithoutFTPs (globaldefs.NameAndStringValue_T[] managedElementName, short[] tpLayerRateList, short[] connectionLayerRateList, int how_many, terminationPoint.TerminationPointList_THolder tpList, terminationPoint.TerminationPointIterator_IHolder tpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllPTPsWithoutFTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                transmissionParameters.LayerRateList_THelper.write ($out, tpLayerRateList);
                transmissionParameters.LayerRateList_THelper.write ($out, connectionLayerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                tpList.value = terminationPoint.TerminationPointList_THelper.read ($in);
                tpIt.value = terminationPoint.TerminationPointIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllPTPsWithoutFTPs (managedElementName, tpLayerRateList, connectionLayerRateList, how_many, tpList, tpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllPTPsWithoutFTPs


  /**
     * <p>Note: This interface has been added in version 3 to return FTPs 
     * only. It allows more selective retrieval than the modified 
     * getAllPTPs() which now returns PTPs and FTPs. </p>
     * <p>This operation has exactly the same behaviour as 
     * getAllPTPs(), but instead of returning both PTPs and FTPs it returns 
     * solely FTPs</p>
     *
     * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
     * Managed Element.
     * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of FTP 
     *  layer rates for which the FTPs are to be fetched. A FTP must contain at 
     *  least one of the layer rates specified to be reported.  If the list is 
     *  empty then FTPs of all rates are returned.
     * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
     *  of connection layer rates for which the FTPs are to be fetched. A FTP must 
     *  support connections for at least one of the
     *  layer rates specified to be reported.  If the list is empty then FTPs for 
     *  all connection rates are returned.
     * <br>unsigned long how_many: Maximum number of FTPs to return in the 
     *  first batch.
     * <br>terminationPoint::TerminationPointList_T tpList: First batch of 
     *  FTPs.
     * <br>terminationPoint::TerminationPointIterator_I tpIt: Iterator to 
     *  retrieve remaining FTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * As for getAllPTPs().
     **/
  public void getAllFTPs (globaldefs.NameAndStringValue_T[] managedElementName, short[] tpLayerRateList, short[] connectionLayerRateList, int how_many, terminationPoint.TerminationPointList_THolder tpList, terminationPoint.TerminationPointIterator_IHolder tpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllFTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                transmissionParameters.LayerRateList_THelper.write ($out, tpLayerRateList);
                transmissionParameters.LayerRateList_THelper.write ($out, connectionLayerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                tpList.value = terminationPoint.TerminationPointList_THelper.read ($in);
                tpIt.value = terminationPoint.TerminationPointIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllFTPs (managedElementName, tpLayerRateList, connectionLayerRateList, how_many, tpList, tpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllFTPs


  /**
     * <p>Note: This interface has been enhanced in version 3 to return both PTPs 
     * and FTPs (maximising inter-version compatibility). Two new operations have 
     * been added to getAllPTPNamesWithoutFTPs() and getAllFTPNames()
     * to allow more selective retrieval. </p>
     * <p>This operation has exactly the same behaviour as getAllPTPs(), but
     * instead of returning the entire object structures, this operation returns 
     * their names.</p>
     *
     * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
     * Managed Element.
     * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of 
     *  PTP/FTP layer rates for which the PTPs/FTPs are to be fetched. A PTP/FTP 
     *  must contain at least one of the layer rates specified to be reported.  If 
     *  the list is empty then PTPs/FTPs of all rates are returned.
     * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
     *  of connection layer rates for which the PTPs/FTPs are to be fetched. A 
     *  PTP/FTP must support connections for at least one of the
     *  layer rates specified to be reported.  If the list is empty then PTPs/FTPs 
     *  for all connection rates are returned.
     * <br>unsigned long how_many: Maximum number of PTPs/FTPs to return in 
     *  the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList: First batch of 
     *  PTPs/FTPs.
     * <br>globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve 
     *  the remaining PTPs/FTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br> 
     * As for getAllPTPs().
     **/
  public void getAllPTPNames (globaldefs.NameAndStringValue_T[] managedElementName, short[] tpLayerRateList, short[] connectionLayerRateList, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllPTPNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                transmissionParameters.LayerRateList_THelper.write ($out, tpLayerRateList);
                transmissionParameters.LayerRateList_THelper.write ($out, connectionLayerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllPTPNames (managedElementName, tpLayerRateList, connectionLayerRateList, how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllPTPNames


  /**
     * <p>Note: This interface has been added in version 3 to return PTP 
     * names only. It allows more selective retrieval than the modified 
     * getAllPTPNames() which now returns PTP and FTP names. </p>
     * <p>This operation has exactly the same behaviour as 
     * getAllPTPsWithoutFTPs(), but
     * instead of returning the entire object structures, this operation returns 
     * their names.</p>
     *
     * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
     * Managed Element.
     * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of PTP 
     *  layer rates for which the PTPs are to be fetched. A PTP must contain at 
     *  least one of the layer rates specified to be reported.  If the list is 
     *  empty then PTPs of all rates are returned.
     * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
     *  of connection layer rates for which the PTPs are to be fetched. A PTP must 
     *  support connections for at least one of the
     *  layer rates specified to be reported.  If the list is empty then PTPs for 
     *  all connection rates are returned.
     * <br>unsigned long how_many: Maximum number of PTPs to return in the 
     *  first batch.
     * <br>globaldefs::NamingAttributesList_T nameList: First batch of PTPs.
     * <br>globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve 
     *  the remaining PTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br> 
     * As for getAllPTPs().
     **/
  public void getAllPTPNamesWithoutFTPs (globaldefs.NameAndStringValue_T[] managedElementName, short[] tpLayerRateList, short[] connectionLayerRateList, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllPTPNamesWithoutFTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                transmissionParameters.LayerRateList_THelper.write ($out, tpLayerRateList);
                transmissionParameters.LayerRateList_THelper.write ($out, connectionLayerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllPTPNamesWithoutFTPs (managedElementName, tpLayerRateList, connectionLayerRateList, how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllPTPNamesWithoutFTPs


  /**
     * <p>Note: This interface has been added in version 3 to return FTP 
     * names only. It allows more selective retrieval than the modified 
     * getAllPTPNames() which now returns PTP and FTP names. </p>
     * <p>This operation has exactly the same behaviour as getAllFTPs(),
     * but instead of returning the entire object structures, this 
     * operation returns their names.</p>
     *
     * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
     * Managed Element.
     * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of FTP 
     *  layer rates for which the FTPs are to be fetched. A FTP must contain at 
     *  least one of the layer rates specified to be reported.  If the list is 
     *  empty then FTPs of all rates are returned.
     * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
     *  of connection layer rates for which the FTPs are to be fetched. A FTP must 
     *  support connections for at least one of the
     *  layer rates specified to be reported.  If the list is empty then FTPs for 
     *  all connection rates are returned.
     * <br>unsigned long how_many: Maximum number of FTPs to return in the 
     *  first batch.
     * <br>globaldefs::NamingAttributesList_T nameList: First batch of FTPs.
     * <br>globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve 
     *  the remaining FTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br> 
     * As for getAllPTPs().
     **/
  public void getAllFTPNames (globaldefs.NameAndStringValue_T[] managedElementName, short[] tpLayerRateList, short[] connectionLayerRateList, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllFTPNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                transmissionParameters.LayerRateList_THelper.write ($out, tpLayerRateList);
                transmissionParameters.LayerRateList_THelper.write ($out, connectionLayerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllFTPNames (managedElementName, tpLayerRateList, connectionLayerRateList, how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllFTPNames


  /** 
     * <p>This service returns the termination point structure for the given TP 
     * name (CTP, FTP or PTP). The termination point name must be explicit (a 
     * generic endpoint specification may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * The termination point structure contains <a 
     * href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf >SD1-16 transmission 
     * parameters</a>. The transmission parameters returned will be the parameters
     * in place on the actual termination point on the NE.  If there are no
     * transmission parameters or the TP does not actually exist on the NE,
     * then transmissionParams will be empty. The field transmissionParams
     * will also be empty for "potential" ATM VP/VC CTPs.</p>
     * <br>globaldefs::NamingAttributes tpName: Name of the TP to retrieve.
     * <br>terminationPoint::TerminationPoint_T tp: The retrieved TP.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when tpName does not reference a termination 
     *  point object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a TP object that 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
  public void getTP (globaldefs.NameAndStringValue_T[] tpName, terminationPoint.TerminationPoint_THolder tp) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getTP", true);
                globaldefs.NamingAttributes_THelper.write ($out, tpName);
                $in = _invoke ($out);
                tp.value = terminationPoint.TerminationPoint_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getTP (tpName, tp        );
            } finally {
                _releaseReply ($in);
            }
  } // getTP


  /** 
     * <p>This service returns the Managed Element for the given managed element 
     * name.</p>
     * <br>globaldefs::NamingAttributes managedElementName: Name of the ME to 
     *  retrieve.
     * <br>managedElement::ManagedElement_T me: The retrieved ME.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a
     *  managed element object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to the managed element is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getManagedElement (globaldefs.NameAndStringValue_T[] managedElementName, managedElement.ManagedElement_THolder me) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getManagedElement", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                $in = _invoke ($out);
                me.value = managedElement.ManagedElement_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getManagedElement (managedElementName, me        );
            } finally {
                _releaseReply ($in);
            }
  } // getManagedElement


  /**
     * <p>This allows an NMS to request all of the CTPs that it is potentially 
     * capable of supporting in all possible mapping configurations, at the 
     * specified rates and that are contained by the
     * specified termination point.</p>
     *
     * <p>This service returns all potential contained CTPs for a given TP. The TP 
     * may be a PTP, an FTP or a CTP. If the layerRateList is empty then 
     * contained CTPs at all flexible and/or static LayerRates are 
     * returned.</p>
     *
     * <p>For an OC3 PTP that has the potential of mapping to 
     * VT1.5 the response would contain 3 STS1 CTPs and 84 VT1.5 CTPs;
     * on a T1 PTP, the contained TPs would be one T1 CTP; for
     * an STS1 CTP the response would contain 28 VT1.5 CTPs.  
     * In the case where an OC3 PTP supports mapping 
     * to T1s and VT1.5,
     * then the contained list for the OC3 PTP
     * could be 1 STS3c, 3 STS1, 84 VT1.5 and 84 T1 CTPs;  
     * if a VT1.5 CTP is provided, 1 T1 CTP is returned;
     * if a T1 CTP is provided, the result is an empty list.</p>
     *
     * <p>Whenever a protection group is involved, the behaviour of
     * this service is described below:</p>
     *
     * <TABLE BORDER=2 COLS=2 WIDTH="80%">
     * <TR>
     * <TD>Scenario</TD><TD>Query On Worker TPs </TD><TD>Query On Protection 
     * TPs</TD>
     * </TR>
     * <TR>
     * <TD>Before the Protection Group is created</TD>
     * <TD>returns list of all CTPs </TD>
     * <TD>returns list of all CTPs</TD>
     * </TR>
     * <TR>
     * <TD>After ProtectionGroup is created, if extra 
     * (preemptible/non-pre-emptible) traffic is allowed.</TD>
     * <TD>returns list of all CTPs </TD>
     * <TD>returns list of all CTPs</TD>
     *</TR>
     * <TR>
     * <TD>After ProtectionGroup is created, if extra 
     * (preemptible/non-pre-emptible) traffic is not allowed </TD>
     * <TD>returns list of CTPs that allow protected traffic</TD>
     * <TD>returns an empty list (regardless of the switch status)</TD>
     * </TR>
     * </TABLE>
     * 
     * <p>In case the protection group is created after a query is made, 
     * no object delete notification is 
     * made, the NMS is expected to query the ports in the protection group 
     * to find the list of contained CTPs.</p>
     *
     * <p>When an NMS is interacting with an EMS that supports ATM, this operation
     * needs to be used with caution. The reason for this is that, in ATM, there
     * can be a prohibitively large number of potential VP and VC CTPs returned
     * by this operation. For retrieving ATM CTPs, the getContainedInUseTPs()
     * operation should be considered.</p>
     *
     * <p>If DWDM, SONET and/or SDH is combined with ATM, it is advisable that 
     * this operation be used with the appropriate DWDM, SONET and/or SDH layer  
     * rates entered into the layerRateList. Otherwise, ATM CTPs will be returned 
     * and the resulting list of contained TPs could get prohibitive.</p>
     * 
     * <p>For details on how TPs should be modelled, see
     * <a href=../../../supportingDocumentation/SD1-18_layers.pdf >
     * SD1-18 Functional Modelling Concepts</a>.</p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>globaldefs::NamingAttributes_T tpName: The name of the PTP, FTP or 
     *  CTP for which to get contained CTPs. The 
     * termination point name must be explicit (a generic endpoint specification 
     * may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>transmissionParameters::LayerRateList_T layerRateList: The list of 
     *  the rates of the contained CTPs to report. An 
     *  empty list indicates to the EMS to report all contained CTPs (of all 
     *  rates).
     * <br>unsigned long how_many: Maximum number of contained CTPs to report in 
     *  the first batch.
     * <br>TerminationPointList_T tpList: First batch of contained CTPs.
     * <br>TerminationPointIterator_I tpIt: Iterator to retrieve the remaining 
     *  contained CTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when tpName does not reference a PTP, FTP or 
     *  CTP object or layerRateList contains undefined rates<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a PTP, FTP or CTP 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
    * <br>
     **/
  public void getContainedPotentialTPs (globaldefs.NameAndStringValue_T[] tpName, short[] layerRateList, int how_many, terminationPoint.TerminationPointList_THolder tpList, terminationPoint.TerminationPointIterator_IHolder tpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainedPotentialTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, tpName);
                transmissionParameters.LayerRateList_THelper.write ($out, layerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                tpList.value = terminationPoint.TerminationPointList_THelper.read ($in);
                tpIt.value = terminationPoint.TerminationPointIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainedPotentialTPs (tpName, layerRateList, how_many, tpList, tpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainedPotentialTPs


  /** 
     * <p>This operation has exactly the same behaviour as 
     * getContainedPotentialTPs(), but instead of returning the entire object 
     * structures, this operation returns their names.</p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>globaldefs::NamingAttributes_T tpName: Name of the PTP, FTP or CTP 
     * for which to get contained CTPs. The 
     * termination point name must be explicit (a generic endpoint specification 
     * may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>transmissionParameters::LayerRateList_T layerRateList: the list of 
     * the rates of the contained CTPs to be reported. An 
     * empty list indicates to the EMS to get all contained CTPs (of all rates).
     * <br>unsigned long how_many: Maximum number of contained CTPs to return 
     * in the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList: First batch of 
     * contained CTPs.
     * <br>globaldefs::NamingAttributesListIterator_I nameIt: Iterator to 
     * retrieve the remaining contained CTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * As for getContainedPotentialTPs().
     **/
  public void getContainedPotentialTPNames (globaldefs.NameAndStringValue_T[] tpName, short[] layerRateList, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainedPotentialTPNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, tpName);
                transmissionParameters.LayerRateList_THelper.write ($out, layerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainedPotentialTPNames (tpName, layerRateList, how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainedPotentialTPNames


  /** 
     * <p>This service is used to retrieve the "in use" CTPs that are contained 
     * within a specific PTP, FTP or CTP, at specific layer rates. 
     * An "in use" CTP is defined as a CTP that is used by an SNC
     * in any state (including pending), either as a CM end point or as an 
     * intermediate connection point, or a CTP that is terminated and mapped.
     * This operation will be used when there are a large number of potential CTPs
     * (e.g., in ATM).</p>
     *
     * <p>Example of usage with respect to ATM:<br>
     * To retrieve all actual ATM Network Interfaces associated with a PTP,
     * this operation will be invoked using the PTP name as the tpName and
     * LR_ATM_NI as the only layer rate in the layerRateList. The VPI and
     * VCI ranges that are specified in the returned ATM Network Interface
     * transmissionParams (i.e., Max_VPI_Bits and Max_VCI_Bits) can then be
     * used to determine the potential VPI/VCI range. A subsequent invocation of
     * this operation using an ATM Network Interface CTP as input can be used to
     * determine which VPIs/VCIs are actually in use (with LR_ATM_VP and LR_ATM_VC
     * included in the connectionRateList).<br></p>
     *
     * <p>Example of usage with respect to SONET/SDH:<br>
     * Consider an STM4 PTP with layerRate: LR_Optical_OC12_and_STM4.
     * Assume that the set of CTPs returned by operation 
     * getContainedPotentialTPs()
     * contains one CTP with layerRate LR_STS3c_and_AU4_VC4 that is terminating
     * an SNC (layerRate LR_STS3c_and_AU4_VC4), and another CTP with layerRate
     * LR_STS3c_and_AU4_VC4 that is terminated and mapped (attribute
     * tpMappingMode is set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING).
     * The CTP with layerRate LR_STS3c_and_AU4_VC4 that is terminated and mapped
     * contains one CTP with layerRate LR_VT2_and_TU12_VC12
     * that is involved in an SNC. None of the other contained CTPs have attribute
     * tpMappingMode set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING, or are
     * involved in an SNC.<br>
     * Operation getContainedInUseTPs then returns three CTPs:<ul>
     * <li>The CTP with layerRate LR_STS3c_and_AU4_VC4 that is terminating an 
     * SNC.</li>
     * <li>The CTP with layerRate LR_STS3c_and_AU4_VC4 that has attribute
     * tpMappingMode set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING.</li>
     * <li>The CTP with layerRate LR_VT2_and_TU12_VC12 that is terminating an 
     * SNC.</li>
     * </ul><br></p>
     * 
     * <p>For details on how TPs should be modelled, see
     * <a href=../../../supportingDocumentation/SD1-18_layers.pdf >
     * SD1-18 Functional Modelling Concepts</a>.</p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>globaldefs::NamingAttributes_T tpName: The name of the PTP, FTP or 
     *  CTP for which to get contained actual CTPs. The 
     * termination point name must be explicit (a generic endpoint specification 
     * may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>transmissionParameters::LayerRateList_T layerRateList: The list of 
     * rates of the contained actual CTPS to be returned.
     * An empty list indicates to the EMS to get all contained actual CTPs (for 
     * all rates).
     * <br>unsigned long how_many: The maximum number of CTPs to be returned in 
     * the first batch.
     * <br>TerminationPointList_T tpList: First batch of contained in use CTPs.
     * <br>TerminationPointIterator_I tpIt: Iterator to retrieve the remaining
     * contained in use CTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when tpName does not reference a PTP, FTP or 
     *  CTP object or layerRateList contains undefined rates<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a PTP, FTP or CTP 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * <br>
     **/
  public void getContainedInUseTPs (globaldefs.NameAndStringValue_T[] tpName, short[] layerRateList, int how_many, terminationPoint.TerminationPointList_THolder tpList, terminationPoint.TerminationPointIterator_IHolder tpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainedInUseTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, tpName);
                transmissionParameters.LayerRateList_THelper.write ($out, layerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                tpList.value = terminationPoint.TerminationPointList_THelper.read ($in);
                tpIt.value = terminationPoint.TerminationPointIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainedInUseTPs (tpName, layerRateList, how_many, tpList, tpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainedInUseTPs


  /**
     * <p>This operation has exactly the same behaviour as 
     * getContainedInUseTPs(), but
     * instead of returning the entire object structures, this operation returns 
     * their names.</p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>globaldefs::NamingAttributes_T tpName: The name of the TP for which 
  
     * to get contained in use TPs. The termination point name must be explicit (a 
     * generic endpoint specification may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>transmissionParameters::LayerRateList_T layerRateList: The list of 
     * rates of the contained in use CTPs to be returned. An 
     * empty list indicates to the EMS to get all contained in use CTPs (of all 
     * rates).
     * <br>unsigned long how_many: Maximum number of CTP names to be returned in 
     * the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList: First batch of CTP 
     * names.
     * <br>globaldefs::NamingAttributesListIterator_I nameIt: Iterator to 
     * retrieve the remaining CTP names.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * As for getContainedInUseTPs().
     **/
  public void getContainedInUseTPNames (globaldefs.NameAndStringValue_T[] tpName, short[] layerRateList, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainedInUseTPNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, tpName);
                transmissionParameters.LayerRateList_THelper.write ($out, layerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainedInUseTPNames (tpName, layerRateList, how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainedInUseTPNames


  /** 
     * <p>This service is used to retrieve the "current" CTPs that are contained 
     * within a specific PTP, FTP or CTP, at specific layer rates. 
     * A "current" CTP is defined as a CTP that is either cross-connectable or 
     * cross-connected,in the current mapping configuration. </p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>globaldefs::NamingAttributes_T tpName: The name of the PTP, FTP or 
     *  CTP for which to get current contained CTPs. The 
     * termination point name must be explicit (a generic endpoint specification 
     * may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>transmissionParameters::LayerRateList_T layerRateList: The list of 
     * rates of the current contained CTPS to be returned.
     * An empty list indicates to the EMS to get all current contained CTPs (of 
     * all rates).
     * <br>unsigned long how_many: The maximum number of CTPs to be returned in 
     * the first batch.
     * <br>TerminationPointList_T tpList: First batch of contained current CTPs.
     * <br>TerminationPointIterator_I tpIt: Iterator to retrieve the remaining
     * contained current CTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when tpName does not reference a PTP, FTP or 
     *  CTP object or layerRateList contains undefined rates<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a PTP, FTP or CTP 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getContainedCurrentTPs (globaldefs.NameAndStringValue_T[] tpName, short[] layerRateList, int how_many, terminationPoint.TerminationPointList_THolder tpList, terminationPoint.TerminationPointIterator_IHolder tpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainedCurrentTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, tpName);
                transmissionParameters.LayerRateList_THelper.write ($out, layerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                tpList.value = terminationPoint.TerminationPointList_THelper.read ($in);
                tpIt.value = terminationPoint.TerminationPointIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainedCurrentTPs (tpName, layerRateList, how_many, tpList, tpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainedCurrentTPs


  /**
     * <p>This operation has exactly the same behaviour as 
     * getContainedCurrentTPs(), but instead of returning the entire object 
     * structures, this operation returns their names.</p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>globaldefs::NamingAttributes_T tpName: The name of the PTP, FTP or 
     *  CTP for which to get current contained CTPs. The 
     * termination point name must be explicit (a generic endpoint specification 
     * may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>transmissionParameters::LayerRateList_T layerRateList: The list of 
     * rates of the current contained CTPS to be returned.
     * An empty list indicates to the EMS to get all current contained CTPs (of 
     * all rates).
     * <br>unsigned long how_many: Maximum number of CTP names to be returned in 
     * the first batch.
     * <br>globaldefs::NamingAttributesList_T nameList: First batch of CTP 
     * names.
     * <br>globaldefs::NamingAttributesListIterator_I nameIt: Iterator to 
     * retrieve the remaining CTP names.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * As for getContainedCurrentTPs().
     **/
  public void getContainedCurrentTPNames (globaldefs.NameAndStringValue_T[] tpName, short[] layerRateList, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainedCurrentTPNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, tpName);
                transmissionParameters.LayerRateList_THelper.write ($out, layerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainedCurrentTPNames (tpName, layerRateList, how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainedCurrentTPNames


  /**
     * <p>This service returns a list of the containing TPs given a CTP. This 
     * will return an PTP or FTP where there is only one level of containment. In 
     * a case of deeper containment this will return a list of CTPs and a PTP or 
     * FTP. 
     * Using the UPSR OC3 example used in getContainedPotentialTPs, 
     * getContainingTPs on the working T1 CTP will return a working STS1 CTP and a 
     * working OC3PTP.
     * If the OC3 was in APS, then getContainingTPs on the T1 CTP would return
     * an STS1 CTP, an OC3 working PTP and an OC3 protect PTP. 
     * 
     * <p>For details on how TPs should be modelled, see
     * <a href=../../../supportingDocumentation/SD1-18_layers.pdf >
     * SD1-18 Functional Modelling Concepts</a>.</p>
     *
     * <br>globaldefs::NamingAttributes tpName: Name of the CTP for which 
     * containing CTPs and PTP/FTP are to be reported. The 
     * termination point name must be explicit (a generic endpoint specification 
     * may not be used in this case). See 
     * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
     * Object Naming</a> for further detail on FTP naming.
     * <br>terminationPoint::TerminationPointList_T tpList: List of the 
     * containing CTPs and PTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when tpName does not reference a CTP 
     *  object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a CTP object that 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getContainingTPs (globaldefs.NameAndStringValue_T[] tpName, terminationPoint.TerminationPointList_THolder tpList) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainingTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, tpName);
                $in = _invoke ($out);
                tpList.value = terminationPoint.TerminationPointList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainingTPs (tpName, tpList        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainingTPs


  /**
     * <p>This operation has exactly the same behaviour as 
     * getContainingTPs(), but
     * instead of returning the entire object structures, this operation returns 
     * their names.</p>
     *
     * <br>globaldefs::NamingAttributes_T tpName: Name of the CTP for which 
     * to get the names of the containing TPs.
     * <br>globaldefs::NamingAttributesList_T tpNameList: List of the names of 
     * the containing TPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * As for getContainingTPs().
     **/
  public void getContainingTPNames (globaldefs.NameAndStringValue_T[] tpName, globaldefs.NamingAttributesList_THolder tpNameList) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainingTPNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, tpName);
                $in = _invoke ($out);
                tpNameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainingTPNames (tpName, tpNameList        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainingTPNames


  /**
     * <p>This allows an NMS to request all of the active alarms and TCAs 
     * for the specified managed element.
     * Alarms that are not reported by the ME to the EMS should not be reported by 
     * this operation. Some alarms may be
     * filtered out (excluded) by specifying their probable causes or severities.
     * </p>
     *
     * <p>The result of this operation is independent of the filtering set up by 
     * the NMS for the notification service. Alarms which ASAP assigned severity 
     * is "NOTALARMED" should not be reported by this operation. </p>
     *
     * <br>globaldefs::NamingAttributes meName: The name of the 
     * Managed Element for which to retrieve alarms and TCAs.
     * <br>notifications::ProbableCauseList_T excludeProbCauseList: List of 
     * probable causes to exclude from the output event list.
     * <br>notifications::PerceivedSeverityList_T excludeSeverityList: List of 
     * severities to exclude from the output event list.
     * <br>unsigned long how_many: Maximum number of events to report in the 
     * first batch.
     * <br>notifications::EventList_T eventList: First batch of events.
     * <br>notifications::EventIterator_I eventIt: Iterator to retrieve the 
     * remaining events.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised when meName does not reference a managed 
     *  element object or excludeProbCauseList or excludeSeverityList contains 
     *  undefined values<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when meName references an ME object that 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * <br>
     **/
  public void getAllActiveAlarms (globaldefs.NameAndStringValue_T[] meName, String[] excludeProbCauseList, notifications.PerceivedSeverity_T[] excludeSeverityList, int how_many, notifications.EventList_THolder eventList, notifications.EventIterator_IHolder eventIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllActiveAlarms", true);
                globaldefs.NamingAttributes_THelper.write ($out, meName);
                notifications.ProbableCauseList_THelper.write ($out, excludeProbCauseList);
                notifications.PerceivedSeverityList_THelper.write ($out, excludeSeverityList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                eventList.value = notifications.EventList_THelper.read ($in);
                eventIt.value = notifications.EventIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllActiveAlarms (meName, excludeProbCauseList, excludeSeverityList, how_many, eventList, eventIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllActiveAlarms


  /**
     * <p>This allows an NMS to request all of the active  alarms and TCAs 
     * for the specified managed element that have not been acknowledged.
     * Alarms that are not reported by the ME to the EMS should not be reported by 
     * this operation. Some alarms may be
     * filtered out (excluded) by specifying their probable causes or severities.
     * </p>
     *
     * <p>The result of this operation is independent of the filtering set up by 
     * the NMS for the notification service. Alarms which ASAP assigned severity 
     * is "NOTALARMED" should not be reported by this operation. </p>
     *
     * <br>globaldefs::NamingAttributes meName: The name of the 
     * Managed Element for which to retrieve unacknowledged alarms and TCAs.
     * <br>notifications::ProbableCauseList_T excludeProbCauseList: List of 
     * probable causes to exclude from the output event list.
     * <br>notifications::PerceivedSeverityList_T excludeSeverityList: List of 
     * severities to exclude from the output event list.
     * <br>unsigned long how_many: Maximum number of events to report in the 
     * first batch.
     * <br>notifications::EventList_T eventList: First batch of events.
     * <br>notifications::EventIterator_I eventIt: Iterator to retrieve the 
     * remaining events.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when meName does not reference a managed 
     *  element object or excludeProbCauseList ofr excludeSeverityList contains 
     *  undefined values<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when meName references an ME object that 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllUnacknowledgedActiveAlarms (globaldefs.NameAndStringValue_T[] meName, String[] excludeProbCauseList, notifications.PerceivedSeverity_T[] excludeSeverityList, int how_many, notifications.EventList_THolder eventList, notifications.EventIterator_IHolder eventIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllUnacknowledgedActiveAlarms", true);
                globaldefs.NamingAttributes_THelper.write ($out, meName);
                notifications.ProbableCauseList_THelper.write ($out, excludeProbCauseList);
                notifications.PerceivedSeverityList_THelper.write ($out, excludeSeverityList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                eventList.value = notifications.EventList_THelper.read ($in);
                eventIt.value = notifications.EventIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllUnacknowledgedActiveAlarms (meName, excludeProbCauseList, excludeSeverityList, how_many, eventList, eventIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllUnacknowledgedActiveAlarms


  /** 
     * <p>This service allows the NMS to set parameters on a specified 
     * Termination Point (CTP, PTP or FTP). See <a 
     * href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf >SD1-16 
     * Layered Transmission Parameters</a> for further information.</p>
     *
     * <p>This operation is best effort (except where specified otherwise for a 
     * particular parameter). The results of the operation are returned
     * so that the NMS is aware of what modifications succeeded.</p>
     *
     * <p>If the source TP of a broadcast system is used as input, then
     * the entire multipoint system will be affected based on the new
     * parameter values for the source TP.</p>
     *
     * <p>The tpMappingMode may be set with this operation. When the mode is
     * set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING, the EMS will terminate the
     * specified CTP. In this case the EMS must create the specified CTP on 
     * the NE if it does not actually exist. 
     * Setting the tpMappingMode of an ATM VP or VC CTP can only be done if
     * the CTP has been created. Note that the tpMappingMode can be set
     * only on the ingress and egress CTPs of an ATM SNC since they are the only
     * ones which may not be cross-connected.</p>
     *
     * <p>No change to tpMappingMode or TransmissionDescriptors will take place if
     * there is any active cross connect (NE cross connect)
     * using the CTP passed in parameter.</p>
     *
     * <p>The transmissionParams is a "delta" list that needs to be
     * applied to the specified TP, i.e. only a subset of the
     * parameters may be specified in the list, in which case only those
     * should be applied in the NE. Transmission parameters are used to associate 
     * a TCA profile with a TP using this service. In this case there are 
     * potentially additional failure modes (see exceptions).</p>
     *
     * <p> The assignment of a Transmission Descriptor (TMD) to a Termination Point (TP) 
     * as egress or ingress TMD by using the TMD's name amounts to an overwriting 
     * of the layered transmission parameters of the TP by the layered transmission 
     * parameters of the TMD, and to an overwriting of the additional info parameters
     * of the TP by the "additional TP information" parameters of the TMD. </p>
     *
     * <br>subnetworkConnection::TPData_T tpInfo: Details of modifications 
     * required.
     * <br>terminationPoint::TerminationPoint_T modifiedTP: Result of 
     * modification.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised if the TP referred to in tpInfo does not 
     *  exist.<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_INVALID_INPUT - Raised when an input parameter is syntactical 
     *  incorrect and raised when a parameter is identified as only "settable" 
     *  using a "specific operation" in the <a 
     *  href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf >SD1-16 
     *  Layered Transmission Parameters</a> document<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable 
     *  to execute the request because at least one of the parameters although 
     *  valid can not be set and that parameter is identified as "not best effort" 
     *  in the <a href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf >SD1-16 
     *  Layered Transmission Parameters</a> document<br>
     * <br>
     **/
  public void setTPData (subnetworkConnection.TPData_T tpInfo, terminationPoint.TerminationPoint_THolder modifiedTP) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setTPData", true);
                subnetworkConnection.TPData_THelper.write ($out, tpInfo);
                $in = _invoke ($out);
                modifiedTP.value = terminationPoint.TerminationPoint_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setTPData (tpInfo, modifiedTP        );
            } finally {
                _releaseReply ($in);
            }
  } // setTPData


  /**
     * <p>This allows an NMS to request a list of the cross-connects for the 
     * specified managed element at the specified layer rates. This operation
     * returns cross-connects between CTPs/FTPs and between GTPs (GTP 
     * cross-connects are described in
     * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC 
     * overview</a>).</p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,   
     * this operation uses an iterator. See   
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>   
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>globaldefs::NamingAttributes_T managedElementName: Name of the 
     * Managed Element for which to retrieve CCs.
     * <br>transmissionParameters::LayerRateList_T connectionRateList: List of 
     * rates for which to retrieve CCs. This must not be an empty list. In this 
     * case an INVALID_INPUT exception is thrown.
     * <br>in unsigned long how_many: Maximum number of CCs to report in the 
     * first batch.
     * <br>subnetworkConnection::CrossConnectList_T ccList: First batch of CCs.
     * <br>subnetworkConnection::CCIterator_I ccIt: Iterator to retrieve 
     * remaining CCs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support GTPs<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised if connectionRateList is empty or contains
     *  invalid rates, or if managedElementName does not reference a managed 
     *  element.<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllCrossConnections (globaldefs.NameAndStringValue_T[] managedElementName, short[] connectionRateList, int how_many, subnetworkConnection.CrossConnectList_THolder ccList, subnetworkConnection.CCIterator_IHolder ccIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllCrossConnections", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                transmissionParameters.LayerRateList_THelper.write ($out, connectionRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                ccList.value = subnetworkConnection.CrossConnectList_THelper.read ($in);
                ccIt.value = subnetworkConnection.CCIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllCrossConnections (managedElementName, connectionRateList, how_many, ccList, ccIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllCrossConnections


  /**
     * <p>The NMS uses this operation to request the creation of a GTP (see 
     * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC overview</a>
     * for further information on GTP usage). The NMS can either specify the list
     * of CTPs comprising the GTP (the list is placed in the listOfTPs parameter) 
     * or, in the case of contiguous CTPs of the same layerRate, the NMS may list 
     * the first CTP (in the initialCTPname parameter) and the number of 
     * following CTPs (in the numberOfCTPs parameter). The NMS 
     * may also provide the EMS with the flexibility to decide the list of CTPs  
     * by using the gtpEffort parameter. In this flexible mode the EMS uses the 
     * listOfTPs parameter or the initialCTPname/ numberOfCTPs parameters to 
     * determine the total requested bandwidth but it may return a GTP (newGTP 
     * parameter) with a different set of CTPs than those indicated in the 
     * original createGTP request. Note that this mode allows for the GTP 
     * components to be instantiated at a later time by the ME (e.g., upon 
     * detection of user's signal). Therefore the operation may successfully 
     * return a newGTP with an empty listOfTPs attribute (to be updated at a 
     * later time once the component CTPs are created in the ME).</p>
     *
     * <br>string userLabel: the userLabel for the GTP. 
     * <br>Boolean forceUniqueness: Specifies whether uniqueness of the userLabel 
     * is required amongst GTPs of the EMS.  The operation will fail if userLabel 
     * is already in use.
     * <br>string owner: the owner of the GTP. 
     * <br> globaldefs::NamingAttributesList_T listOfTPs: the list of CTPs that 
     * comprise the GTP. 
     * <br> globaldefs::NamingAttributesList_T initialCTPname: in cases where the 
     * CTPs are contiguous and of the same layerRate, this parameter is used to 
     * indicate the first CTP in the group. This parameter is used in lieu of the 
     * listOfTPs parameter.  
     * <br>unsigned long numberOfCTPs: This parameter is used in conjunction with 
     * the initialCTPname parameter. It indicates the number of contiguous CTPs 
     * that follow the initial CTP. It equals 1 minus the total number of CTPs in 
     * the GTP.
     * <br>terminationPoint::GTPEffort_T gtpEffort: This parameter is used to 
     * indicate if the GTP bandwidth specification can be met with a different 
     * list of CTPs. 
     * <br> globaldefs::NVSList_T additionalCreationInfo: This parameter contains 
     * additional information concerning the GTP create request. The list may be 
     * empty. For full information see <a 
     * href=../../../supportingDocumentation/SD1-1_additionalInfoUsage.pdf >SD1-1 
     * Additional Information Usage</a>. 
     * <br> terminationPoint::GTP_T newGTP: This output parameter contains the 
     * newly created GTP. 
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support GTPs<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS cannot reply to the GTP 
     *  creation request<br>
     * EXCPT_INVALID_INPUT - Raised if the GTP creation data is not well 
     *  formed<br>
     * EXCPT_OBJECT_IN_USE - Raised if a CTP (to be included in the GTP) is being 
     *  used in an SNC, or is already in another GTP. <br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost 
     *  and this prevents creating the GTP<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void createGTP (String userLabel, boolean forceUniqueness, String owner, globaldefs.NameAndStringValue_T[][] listOfTPs, globaldefs.NameAndStringValue_T[] initialCTPname, int numberOfCTPs, terminationPoint.GTPEffort_T gtpEffort, globaldefs.NameAndStringValue_T[] additionalCreationInfo, terminationPoint.GTP_THolder newGTP) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("createGTP", true);
                $out.write_string (userLabel);
                $out.write_boolean (forceUniqueness);
                $out.write_string (owner);
                globaldefs.NamingAttributesList_THelper.write ($out, listOfTPs);
                globaldefs.NamingAttributes_THelper.write ($out, initialCTPname);
                $out.write_ulong (numberOfCTPs);
                terminationPoint.GTPEffort_THelper.write ($out, gtpEffort);
                globaldefs.NVSList_THelper.write ($out, additionalCreationInfo);
                $in = _invoke ($out);
                newGTP.value = terminationPoint.GTP_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                createGTP (userLabel, forceUniqueness, owner, listOfTPs, initialCTPname, numberOfCTPs, gtpEffort, additionalCreationInfo, newGTP        );
            } finally {
                _releaseReply ($in);
            }
  } // createGTP


  /**
     * <p>The delete GTP operation is used to delete a GTP(see 
     * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC overview</a>
     * for further information on GTP usage). An attempt to delete a 
     * GTP that is involved in a cross connection or SNC should be rejected by the 
     * EMS. This operation is idempotent. If the service is called with the name 
     * of a non-existent GTP, it will succeed.</p>
     *
     * <br>globaldefs::NamingAttributes name of GTP to be deleted
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support deletion of GTPs via 
     *  this interface<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when input parameter is syntactical 
     *  incorrect<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when the GTP to be deleted does not 
     *  exist<br>
     * EXCPT_OBJECT_IN_USE - Raised if the GTP is used in a cross connection<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void deleteGTP (globaldefs.NameAndStringValue_T[] gtpName) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("deleteGTP", true);
                globaldefs.NamingAttributes_THelper.write ($out, gtpName);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                deleteGTP (gtpName        );
            } finally {
                _releaseReply ($in);
            }
  } // deleteGTP


  /**
     * <p>The modify GTP operation is used to add TPs to or delete TPs from a GTP  
     * (see <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC 
     * overview</a> for further information on GTP usage). 
     * For a given request, the NMS can only add or delete CTPs, not both. It 
     * is not possible to add a CTP that is already involved in a cross 
     * connection or SNC, or that is part of another GTP. Attempts to modify a GTP 
     * that is involved in a cross connection (or SNC) should be rejected by the 
     * EMS. The operation is best-effort, i.e., the EMS will add or delete as many 
     * of the identified CTPs as possible. 
     * If the service is called with the name of a non-existent GTP or CTP, it 
     * will fail.</p>
     *
     * <p>If the NMS created a GTP with gtpEffort equal to EFFORT_SAME, this also 
     * implies that the EMS will not modify on its own, i.e., the EMS will only 
     * modify the GTP if requested by the NMS via the modifyGTP operation.</p>
     *
     * <br>globaldefs::NamingAttribute gtpName: name of the GTP to be modified
     * <br>globaldefs::NamingAttributesList tpNames: names of the CTPs to be 
     * added or deleted
     * <br>string actionType: an indication of whether the listed TPs are to be 
     * added or deleted. Two values are possible "add" or "delete".
     * <br>terminationPoint::GTP_T modifiedGTP: the structure for the modified 
     * GTP
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support modification of GTPs 
     *  via this interface<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS cannot reply to the GTP 
     *  modification request.<br>
     * EXCPT_INVALID_INPUT - Raised if GTP modification data is not well 
     *  formed<br>
     * EXCPT_OBJECT_IN_USE - Raised if the GTP is part of a cross connection or 
     *  SNC<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when the GTP to be modified do not exist or 
     *  TPs to be added do not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost 
     *  and this prevents modification of the GTP<br>
     * <br>
     **/
  public void modifyGTP (globaldefs.NameAndStringValue_T[] gtpName, globaldefs.NameAndStringValue_T[][] tpNames, String actionType, terminationPoint.GTP_THolder modifiedGTP) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("modifyGTP", true);
                globaldefs.NamingAttributes_THelper.write ($out, gtpName);
                globaldefs.NamingAttributesList_THelper.write ($out, tpNames);
                $out.write_string (actionType);
                $in = _invoke ($out);
                modifiedGTP.value = terminationPoint.GTP_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                modifyGTP (gtpName, tpNames, actionType, modifiedGTP        );
            } finally {
                _releaseReply ($in);
            }
  } // modifyGTP


  /** 
     * <p>This service returns the GTP structure for the given GTP name(see 
     * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC overview</a>
     * for further information on GTP usage). </p>
     * <br>globaldefs::NamingAttributes gtpName: Name of the GTP to retrieve.
     * <br>terminationPoint::GTP_T gtp: The retrieved GTP.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support this operation<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when gtpName does not reference a GTP 
     *  object<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when gtpName references a GTP object that 
     *  does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
    * <br>
     **/
  public void getGTP (globaldefs.NameAndStringValue_T[] gtpName, terminationPoint.GTP_THolder gtp) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getGTP", true);
                globaldefs.NamingAttributes_THelper.write ($out, gtpName);
                $in = _invoke ($out);
                gtp.value = terminationPoint.GTP_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getGTP (gtpName, gtp        );
            } finally {
                _releaseReply ($in);
            }
  } // getGTP


  /**
     * <p>This operation allows an NMS to request all of the GTPs (on the given  
     * Managed Element) that contain one or more TPs at the specified layer rates.
     * If there are no GTPs that match the layer constraints, an empty list is 
     * returned (see 
     * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC overview</a>
     * for further information on GTP usage). </p>
     * 
     * <p>In order to allow the NMS to deal with a large number of objects,
     * this operation uses an iterator. See
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
     * Managed Element for which to retrieve the GTPs.
     * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of 
     * layer rates for which the GTPs are to be fetched. A GTP must contain at 
     * least one TP having one of the specified layer rates.  If the list is empty 
     * then all GTPs (of all rates) are returned.
     * <br>unsigned long how_many: Maximum number of GTPs to report in the 
     * first batch.
     * <br>terminationPoint::TerminationPointList_T tpList: First batch of 
     * GTPs.
     * <br>terminationPoint::TerminationPointIterator_I tpIt: Iterator to 
     * retrieve remaining GTPs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support this operation<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a 
     *  managed element object, or the tpLayerRateList contains undefined 
     *  rates<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllGTPs (globaldefs.NameAndStringValue_T[] managedElementName, short[] tpLayerRateList, int how_many, terminationPoint.GTPlist_THolder gtpList, terminationPoint.GTPiterator_IHolder gtpIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllGTPs", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                transmissionParameters.LayerRateList_THelper.write ($out, tpLayerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                gtpList.value = terminationPoint.GTPlist_THelper.read ($in);
                gtpIt.value = terminationPoint.GTPiterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllGTPs (managedElementName, tpLayerRateList, how_many, gtpList, gtpIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllGTPs


  /**
     * <p> The getAllGTPNames operation has the same behaviour as 
     * getAllGTPs(), except that only the GTP names are returned.</p>
     * 
     * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
     * Managed Element for which to retrieve the GTP names.
     * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of 
     * layer rates for which the GTP names are to be fetched. A GTP must contain 
     * at least one TP having one of the specified layer rates.  If the list is 
     * empty then all GTP names (of all rates) are returned.
     * <br>unsigned long how_many: Maximum number of GTP names to report in the 
     * first batch.
     * <br>globaldefs::NamingAttributesList_T nameList: First batch of GTP 
     * names.
     * <br>globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve 
     * the remaining GTP names.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * As for getAllGTPs().<br>
     **/
  public void getAllGTPNames (globaldefs.NameAndStringValue_T[] managedElementName, short[] tpLayerRateList, int how_many, globaldefs.NamingAttributesList_THolder nameList, globaldefs.NamingAttributesIterator_IHolder nameIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllGTPNames", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                transmissionParameters.LayerRateList_THelper.write ($out, tpLayerRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                nameList.value = globaldefs.NamingAttributesList_THelper.read ($in);
                nameIt.value = globaldefs.NamingAttributesIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllGTPNames (managedElementName, tpLayerRateList, how_many, nameList, nameIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllGTPNames


  /**
     * <p>The getContainingGTP operation returns the name of the GTP containing a 
     * given CTP (see 
     * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC overview</a>
     * for further information on GTP usage). If the CTP is not  
     * contained in a GTP, the gtp output parameter is left empty. </p>
     * <br>globaldefs::NamingAttributes_T ctpName: The name of the CTP for which 
     * the NMS wants to know the containing GTP.
     * <br>terminationPoint::GTP_T gtp: The name of the GTP containing the CTP. 
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_INVALID_INPUT - Raised if ctpName does not reference a 
     *  terminationPoint object <br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when ctpName references an object that does 
     *  not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost, 
     *  and communication with the ME is needed to determine the containing 
     *  GTP<br>
     * <br>
     **/
  public void getContainingGTP (globaldefs.NameAndStringValue_T[] ctpName, terminationPoint.GTP_THolder gtp) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getContainingGTP", true);
                globaldefs.NamingAttributes_THelper.write ($out, ctpName);
                $in = _invoke ($out);
                gtp.value = terminationPoint.GTP_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getContainingGTP (ctpName, gtp        );
            } finally {
                _releaseReply ($in);
            }
  } // getContainingGTP


  /**
     * <p>This operation enables (activates, or turns on) alarm reporting 
     * for a GTP.</p>
     *
     * <p>The EMS sends an attribute value change notification in case of 
     * success.</p>
     *
     * <br>globaldefs::NamingAttributes_T gtpName: the GTP on which to 
     * activate alarm reporting. 
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when gtpName does not reference a GTP<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when gtpName references an object
     *  that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when alarm reporting can not be enabled 
     *  for the GTP.<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to the managedElement is 
     *  lost<br>
     * <br>
     **/
  public void setGtpAlarmReportingOn (globaldefs.NameAndStringValue_T[] gtpName) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setGtpAlarmReportingOn", true);
                globaldefs.NamingAttributes_THelper.write ($out, gtpName);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setGtpAlarmReportingOn (gtpName        );
            } finally {
                _releaseReply ($in);
            }
  } // setGtpAlarmReportingOn


  /**
     * <p> This operation disables (deactivates, or turns off) alarm reporting on 
     * a GTP.</p>
     *
     * <p>The EMS sends an attribute value change notification in case of 
     * success.</p>
     *
     * <br>globaldefs::NamingAttributes_T gtpName: name of the GTP
     * on which to deactivate alarm reporting.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when gtpName does not reference a GTP<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when gtpName references an object
     *  that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when alarm reporting can not be disabled 
     *  for the GTP<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
  public void setGtpAlarmReportingOff (globaldefs.NameAndStringValue_T[] gtpName) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setGtpAlarmReportingOff", true);
                globaldefs.NamingAttributes_THelper.write ($out, gtpName);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setGtpAlarmReportingOff (gtpName        );
            } finally {
                _releaseReply ($in);
            }
  } // setGtpAlarmReportingOff


  /**
     * <p>This service verifies the egress and/or ingress TMD state
     * of the specified TP identified by tpName.</p>
     *
     * <p>According to the requested transmission direction it checks
     * whether a TMD is assigned as egress and/or ingress TMD to the TP.
     * If this is true it first verifies the existence of the assigned TMD(s)
     * and then compares the transmission parameters of the TMD and TP,
     * and the additional TP info parameters of the TMD with the additional
     * info parameters of the TP.</p>
     *
     * <p>If a TMD parameter is not present as a TP parameter or is present but
     * with a different value, this is called a "parameter mismatch", and the TMD
     * state will take the value "mismatch".  The service returns the current
     * TMD state and all mismatched transmission or additional TP info
     * parameters of the TMD (which should mostly be none) as its output.</p>
     *
     * <br>globaldefs::NamingAttributes_T tpName:
     * the TP whose TMD assignment(s) shall be verified
     *
     * <br>terminationPoint::Directionality_T direction: the direction
     * for which the TMD assignment(s) of the TP shall be verified
     * D_SOURCE refers to the egress TMD state, D_SINK refers to the ingress
     * TMD state, D_BIDRECTIONAL refers to the egress and ingress TMD states,
     * and D_NA is not allowed
     *
     * <br>string tmdAssignmentState: the TMD state (s) of the TP
     * as determined by the verification procedure;
     * if both the egress and ingress TMD states are requested and their
     * values are different, the concatenation of the egress TMD state
     * with the ingress TMD state is returned, separated by a semicolon
     *
     * <br>transmissionParameters::LayeredParameterList_T transmissionParams:
     * a "delta" list of mismatched TMD transmission parameters, or empty. See<a 
     * href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf >SD1-16 
     * Layered Transmission Parameters</a> for more details.
     *
     * <br>globaldefs::NVSList_T additionalTPInfo: a "delta" list
     * of mismatched additional TP info parameters, or empty
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal
     *  failure (see errorReason attribute of ProcessingFailureException())<br>
     * EXCPT_INVALID_INPUT - Raised when tpName is incorrectly formed,
     *  or one or direction value is invalid<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references an object
     *  that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when the communication to the managed
     *  element containing tpName is lost<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable or unwilling to 
     *  execute the request<br>
     * <br>
     **/
  public void verifyTMDAssignment (globaldefs.NameAndStringValue_T[] tpName, terminationPoint.Directionality_T direction, org.omg.CORBA.StringHolder tmdAssignmentState, transmissionParameters.LayeredParameterList_THolder transmissionParams, globaldefs.NVSList_THolder additionalTPInfo) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("verifyTMDAssignment", true);
                globaldefs.NamingAttributes_THelper.write ($out, tpName);
                terminationPoint.Directionality_THelper.write ($out, direction);
                $in = _invoke ($out);
                tmdAssignmentState.value = $in.read_string ();
                transmissionParams.value = transmissionParameters.LayeredParameterList_THelper.read ($in);
                additionalTPInfo.value = globaldefs.NVSList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                verifyTMDAssignment (tpName, direction, tmdAssignmentState, transmissionParams, additionalTPInfo        );
            } finally {
                _releaseReply ($in);
            }
  } // verifyTMDAssignment


  /**
     * <p>This operation has exactly the same behaviour as 
     * getAllCrossConnections(), but instead returns only fixed Cross Connection 
     * object structures. Fixed cross connections are cross connections which cannot be deleted by an NMS.</p>
     *
     * <p>A cross connection is identified as fixed using additional information. 
     * See <a href=../../../supportingDocumentation/SD1-1_additionalInfoUsage.pdf >SD1-1 
     * Additional Information Usage</a> for detail on additional information
     * for SNCs, cross connections and TPs.</p>
     *
     * <p>In order to allow the NMS to deal with a large number of objects,   
     * this operation uses an iterator. See   
     * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>   
     * for information on how iterators are used in this interface.</p>
     * 
     * <br>globaldefs::NamingAttributes_T managedElementName: Name of the 
     * Managed Element for which to retrieve CCs.
     * <br>transmissionParameters::LayerRateList_T connectionRateList: List of 
     * rates for which to retrieve CCs. This must not be an empty list. In this 
     * case an INVALID_INPUT exception is thrown.
     * <br>unsigned long how_many: Maximum number of CCs to report in the 
     * first batch.
     * <br>subnetworkConnection::CrossConnectList_T ccList: First batch of CCs.
     * <br>subnetworkConnection::CCIterator_I ccIt: Iterator to retrieve 
     * remaining CCs.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised if connectionRateList is empty or contains
     *  invalid rates, or if managedElementName does not reference a managed 
     *  element.<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
     *  that the EMS can support has been reached<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * <br>
     **/
  public void getAllFixedCrossConnections (globaldefs.NameAndStringValue_T[] managedElementName, short[] connectionRateList, int how_many, subnetworkConnection.CrossConnectList_THolder ccList, subnetworkConnection.CCIterator_IHolder ccIt) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAllFixedCrossConnections", true);
                globaldefs.NamingAttributes_THelper.write ($out, managedElementName);
                transmissionParameters.LayerRateList_THelper.write ($out, connectionRateList);
                $out.write_ulong (how_many);
                $in = _invoke ($out);
                ccList.value = subnetworkConnection.CrossConnectList_THelper.read ($in);
                ccIt.value = subnetworkConnection.CCIterator_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getAllFixedCrossConnections (managedElementName, connectionRateList, how_many, ccList, ccIt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAllFixedCrossConnections


  /**
     * <p> The operation is used to retrieve fixed connection schemes related to 
     * normal and inverse multiplexing. 
     * Fixed cross connections are cross connections which cannot be deleted by an NMS.</p>
     *
     * <p>A cross connection is identified as fixed using additional information. 
     * See <a href=../../../supportingDocumentation/SD1-1_additionalInfoUsage.pdf >SD1-1 
     * Additional Information Usage</a> for detail.</p>
     *
     * <p>The operation takes as an input a TP and if this TP may be or is 
     * involved in a multiplexing or inverse multiplexing scheme, it will 
     * report:<ul>
     * <li>The TP containing the fixed layer.</li>
     * <li> the list of potential fixed cross connects that will exist if the 
     * containing TP's clientConnectivity or serverConnectivity is set to 
     * "Connected" (i.e. If the containing TP is set to multiplexing or inverse 
     * multiplexing).</li>
     * </ul><br></p> 
     * 
     * <p>If the clientConnectivity (resp. serverConnectivity) of the TP is 
     * currently set to "Connected", the potentialCCList matches the list of 
     * active fixed cross connects that involve its client TPs (resp. server 
     * TPs).</p>
     *
     * <p>If the TP client layer (resp. server layer) is always fixed cross 
     * connected (hard-wired), the potentialCCList always matches the list of 
     * active fixed cross connects that involve the client TPs (resp. server 
     * TPs).</p>
     *
     * <br>globaldefs::NamingAttributes_T inputTP: any TP of the ME. The 
     * operation will return the multiplexing or inverse multiplexing scheme in 
     * which this TP is involved. The input TP may be either the containing TP or 
     * one of the end TPs of the portentialCCList.
     * <br>globaldefs::NamingAttributes_T ContainingTP: The TP supporting the 
     * attribute clientConnectivity or serverConnectivity
     * <br>globaldefs::NamingAttributes_T PortentialCCList: the list of fixed 
     * Cross Connect of that multiplexing scheme, i.e. the list of cross connects  
     * that will exist when the containing TP clientConnectivity or 
     * serverConnectiivty is set to "Connected". The A_end TPs of the cross 
     * connects should be the low order TPs that can be flexibly cross connected, 
     * and the Z_end TPs the TP client of the high order TP. The list of cross 
     * connect does not take any specific order. If there are no potential fixed 
     * cross connects and empty list is returned.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised if inputTP does not reference a TP.<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when inputTP references a TP 
     *  object that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when TP is neither a higher order TP that 
     *  supports fixed multiplexing nor a lower order TP that supports fixed 
     *  inverse multiplexing<br>
     * <br>
     **/
  public void getPotentialFixedCCs (globaldefs.NameAndStringValue_T[] inputTP, globaldefs.NVSList_THolder ContainingTP, globaldefs.NVSList_THolder potentialCCList) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getPotentialFixedCCs", true);
                globaldefs.NamingAttributes_THelper.write ($out, inputTP);
                $in = _invoke ($out);
                ContainingTP.value = globaldefs.NamingAttributes_THelper.read ($in);
                potentialCCList.value = globaldefs.NamingAttributes_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getPotentialFixedCCs (inputTP, ContainingTP, potentialCCList        );
            } finally {
                _releaseReply ($in);
            }
  } // getPotentialFixedCCs


  /**
     * <p>The nativeEMSName is owned by the EMS.  It represents how an EMS user 
     * addresses an object on the EMS GUI.  The EMS may or may not support 
     * changing this value.</p>
     *
     * <p>When an object is created by the EMS, the EMS selects the nativeEMSName 
     * for the object.</p>
     *
     * <p>When an object is created by an NMS, the NMS specifies the userLabel for  
     * the object. If the EMS supports setting of nativeEMSNames, the 
     * nativeEMSName should be set to the same value as the userLabel.  If the EMS 
     * does not support setting of nativeEMSNames, or if the nativeEMSName has 
     * constraints that the userLabel does not satisfy, the EMS selects the 
     * nativeEMSName for the object.</p>
     *
     * <p>After an object has been created, the nativeEMSName may be changed by 
     * the NMS, if the EMS supports this functionality, using the setNativeEMSName 
     * operation.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName
     * <br> string nativeEMSName
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which 
     *  does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the nativeEMSName can not be set for 
     *  the specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost
     * <br>
     **/
  public void setNativeEMSName (globaldefs.NameAndStringValue_T[] objectName, String nativeEMSName) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setNativeEMSName", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                $out.write_string (nativeEMSName);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setNativeEMSName (objectName, nativeEMSName        );
            } finally {
                _releaseReply ($in);
            }
  } // setNativeEMSName


  /**
     * <p>The userLabel is owned by the NMSes.  It is a string assigned by an NMS 
     * to an object. The difference between the userLabel and the NamingAttributes 
     * name is that the userLabel is an attribute of the objects that 
     * may be "set" by the NMS through well defined interfaces (setUserLabel).</p>
     *
     * <p>When an object is created by an NMS, the NMS specifies the userLabel for 
     * the object.</p>
     *
     * <p>When an object is created by the EMS, the EMS sets the userLabel to the 
     * nativeEMSName.</p>
     *
     * <p>Once an object is created, the userLabel may only be changed by an NMS 
     * through the setUserLabel operation.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName: Name of the object for 
     *  which to change the userLabel.
     * <br> string userLabel: New user label to assign to the object
     * <br> boolean enforceUniqueness: Specifies whether or not userLabel should 
     * be checked for uniqueness amongst objects of the same class within the EMS.  
     * If true, then the operation will fail if userLabel is already in use.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which 
     *  does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the userLabel can not be set for the 
     *  specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is 
     *  not met<br>
     * <br>
     **/
  public void setUserLabel (globaldefs.NameAndStringValue_T[] objectName, String userLabel, boolean enforceUniqueness) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setUserLabel", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                $out.write_string (userLabel);
                $out.write_boolean (enforceUniqueness);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setUserLabel (objectName, userLabel, enforceUniqueness        );
            } finally {
                _releaseReply ($in);
            }
  } // setUserLabel


  /** 
     * <p>This service sets the owner attribute of the specified object.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName
     * <br> string owner
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
     *  failure<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
     *  that does not exist<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the owner can not be set for the 
     *  specified object<br>
     * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
     *  lost<br>
     * <br>
     **/
  public void setOwner (globaldefs.NameAndStringValue_T[] objectName, String owner) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setOwner", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                $out.write_string (owner);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setOwner (objectName, owner        );
            } finally {
                _releaseReply ($in);
            }
  } // setOwner


  /** 
     * <p>This service retrieves the capabilities of the manager.
     * All non-specified capabilities are assumed to be unsupported.</p>
     *
     * <br> CapabilityList_T capabilities
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, and cannot determine the reason it could not comply, it may raise this exception. <br>
     **/
  public void getCapabilities (common.CapabilityList_THolder capabilities) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getCapabilities", true);
                $in = _invoke ($out);
                capabilities.value = common.CapabilityList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getCapabilities (capabilities        );
            } finally {
                _releaseReply ($in);
            }
  } // getCapabilities


  /**
     * <p>This service sets the additional info attribute
     * of the object identified by objectName. This operation should be used
     * to set both vendor specific attributes as well as the attributes that
     * are formally defined in this interface specification. See <a 
     * href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     * Additional Information Usage</a> for further details.</p>
     *
     * <p>As an input only the list of parameters to be changed, removed, or
     * added shall be provided.  If an entry is to be removed, "-" shall
     * be specified as a value.  If a parameter is specified that is currently
     * not part of the additionalInfo attribute of the specified object
     * that parameter is added by the EMS with the specified value.
     * The EMS may reject removal and addition requests, however.</p>
     *
     * <p> The operation is best effort (except where specified otherwise for a 
     * particular parameter).  The output specifies the
     * values which were actually set.</p>
     *
     * <br> globaldefs::NamingAttributes_T objectName: the managed object
     * whose additional info parameters are intended to get modified
     *
     * <br> globaldefs::NVSList_T additionalInfo: list of parameters
     * to be changed, added, or removed (input), updated to provide the
     * actually changed or added parameters (output)
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this
     *  service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal
     *  failure (see errorReason attribute of ProcessingFailureException())<br>
     * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed,
     *  raised when an input parameter is syntactical incorrect and raised when a 
     *  parameter is identified as only "settable" using a "specific operation" in 
     *  the <a href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     *  Additional Information Usage</a> document<br>
     * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
     *  that does not exist<br>
     * EXCPT_NE_COMM_LOSS - Raised when the communication to the managed
     *  element containing or hosting objectName is lost<br>
     * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable 
     *  to execute the request because at least one of the parameters although 
     *  valid can not be set and that parameter is identified as "not best effort" 
     *  in the <a href=../../../supportingDocumentation/SD1-1_AdditionalInfoUsage.pdf >SD1-1 
     *  Additional Information Usage</a> document)<br>
     * <br>
  
     **/
  public void setAdditionalInfo (globaldefs.NameAndStringValue_T[] objectName, globaldefs.NVSList_THolder additionalInfo) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setAdditionalInfo", true);
                globaldefs.NamingAttributes_THelper.write ($out, objectName);
                globaldefs.NVSList_THelper.write ($out, additionalInfo.value);
                $in = _invoke ($out);
                additionalInfo.value = globaldefs.NVSList_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setAdditionalInfo (objectName, additionalInfo        );
            } finally {
                _releaseReply ($in);
            }
  } // setAdditionalInfo

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:mtnm.tmforum.org/managedElementManager/ManagedElementMgr_I:1.0", 
    "IDL:mtnm.tmforum.org/common/Common_I:1.0"};

  public String[] _ids ()
  {
    return (String[])__ids.clone ();
  }

  private void readObject (java.io.ObjectInputStream s) throws java.io.IOException
  {
     String str = s.readUTF ();
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     org.omg.CORBA.Object obj = orb.string_to_object (str);
     org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate ();
     _set_delegate (delegate);
   } finally {
     orb.destroy() ;
   }
  }

  private void writeObject (java.io.ObjectOutputStream s) throws java.io.IOException
  {
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     String str = orb.object_to_string (this);
     s.writeUTF (str);
   } finally {
     orb.destroy() ;
   }
  }
} // class _ManagedElementMgr_IStub
