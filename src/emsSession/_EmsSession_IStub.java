package emsSession;


/**
* emsSession/_EmsSession_IStub.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from emsSession.idl
* Wednesday, June 15, 2016 7:24:35 PM COT
*/


/** 
   * <p>A handle to an instance of this interface is gained via the
   * emsSessionInterface parameter of the getEmsSession()
   * operation in EmsSessionFactory_I.</p>
   */
public class _EmsSession_IStub extends org.omg.CORBA.portable.ObjectImpl implements emsSession.EmsSession_I
{


  /**
     * <p>This allows an NMS to request the manager interfaces that the EMS 
     * implements</p>
     * <br>supportedManagerList: The list of manager names supported
     * by the EMS in the form <i>::managerName_T </i>
     * where <i>::managerName_T </i> is one of the following defined manager 
     * strings
     * <ol>
     * <li> "EMS" (mandatory)
     * <li> "ManagedElement" (mandatory)
     * <li> "MultiLayerSubnetwork" (mandatory)
     * <li> "TrafficDescriptor"
     * <li> "PerformanceManagement"
     * <li> "Protection"
     * <li> "EquipmentInventory"
     * <li> "Maintenance"
     * <li> "softwareAndDataManager"
     * <li> "transmissionDescriptor"
     * <li> "GuiCutThrough" (mandatory)
     * <li> "FlowDomain"         
     * <li> "MultiLayerSNPPLink"
     * <li> "TrafficConditioningProfile"
     * <li> "MLSNPP"  
     * </ol>
     * Additional managerName strings can be defined without changing this IDL.
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_ACCESS_DENIED  - Raised in case of security violation<br><br>
     **/
  public void getSupportedManagers (emsSession.EmsSession_IPackage.managerNames_THolder supportedManagerList) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getSupportedManagers", true);
                $in = _invoke ($out);
                supportedManagerList.value = emsSession.EmsSession_IPackage.managerNames_THelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getSupportedManagers (supportedManagerList        );
            } finally {
                _releaseReply ($in);
            }
  } // getSupportedManagers


  /**
     * <p>This allows an NMS to gain access to the specified manager 
     * interface without using the OMG Naming Service.</p>
     *
     * <br>managerName: The class or type of manager object that the client 
     * wants to access (see getSupportedManagers()). 
     * <br>managerInterface: The actual object returned will implement the 
     * specified manager interface.  However it is returned as a 
     * Common_I object so that this operation can be generic.  The client should 
     * narrow the returned object to the correct object type.
     * 
     * <p>Attempting to gain access to the following manager interfaces
     * may <u>not</u> raise EXCPT_NOT_IMPLEMENTED:<br>
     * EMS<br>
     * ManagedElement<br>
     * MultiLayerSubnetwork<br>
     * GuiCutThrough</p>
     *
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_ACCESS_DENIED  - Raised in case of security violation<br><br>
     **/
  public void getManager (String managerName, common.Common_IHolder managerInterface) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getManager", true);
                $out.write_string (managerName);
                $in = _invoke ($out);
                managerInterface.value = common.Common_IHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getManager (managerName, managerInterface        );
            } finally {
                _releaseReply ($in);
            }
  } // getManager


  /**
     * <p>This operation allows an NMS to gain access to the event channel to 
     * receive notifications. It returns a reference to a NotifyChannel 
     * interface (which is an EventChannel).When the EMS supports the OMG Telecom 
     * Log service, this operation will return a reference to a NotifyLog 
     * interface (which is a NotifyChannel).</p>
     *
     * <br>CosNotifyChannelAdmin::EventChannel eventChannel: The event channel 
     * (NotifyChannel or NotifyLog) to be used by the NMS.
     * 
     * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
     * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
     * EXCPT_INTERNAL_ERROR - Raised in case of a non-specific EMS internal 
     *  failure<br>
     * EXCPT_UNABLE_TO_COMPLY - If the EMS cannot comply with the request, 
     * and cannot determine the reason it could not comply, 
     * it may raise this exception. <br>
     * EXCPT_ACCESS_DENIED - Raised in case of security violation<br><br>
     **/
  public void getEventChannel (CosNotifyChannelAdmin.EventChannelHolder eventChannel) throws globaldefs.ProcessingFailureException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getEventChannel", true);
                $in = _invoke ($out);
                eventChannel.value = CosNotifyChannelAdmin.EventChannelHelper.read ($in);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:mtnm.tmforum.org/globaldefs/ProcessingFailureException:1.0"))
                    throw globaldefs.ProcessingFailureExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                getEventChannel (eventChannel        );
            } finally {
                _releaseReply ($in);
            }
  } // getEventChannel


  /**
     * <p>This attribute contains a reference to the Session_I on the other side 
     * (NMS/EMS)to which the object is associated.
     * This attribute can be checked to make sure the NmsSession_I/EmsSession_I 
     * association is still valid (in particular in case of communication 
     * failures).</p>
     **/
  public session.Session_I associatedSession ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("_get_associatedSession", true);
                $in = _invoke ($out);
                session.Session_I $result = session.Session_IHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return associatedSession (        );
            } finally {
                _releaseReply ($in);
            }
  } // associatedSession


  /**
     * <p> Allows for the detection of loss of communication.
     * It is implementation specific to differenciate intermittent 
     * problems from loss of connection.</p>
     **/
  public void ping ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("ping", true);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                ping (        );
            } finally {
                _releaseReply ($in);
            }
  } // ping


  /**
     * <p> Allows for a controlled disconnect between parties.
     * All resources allocated for the session are deleted by operation.</p>
     **/
  public void endSession ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("endSession", false);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                endSession (        );
            } finally {
                _releaseReply ($in);
            }
  } // endSession

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:mtnm.tmforum.org/emsSession/EmsSession_I:1.0", 
    "IDL:mtnm.tmforum.org/session/Session_I:1.0"};

  public String[] _ids ()
  {
    return (String[])__ids.clone ();
  }

  private void readObject (java.io.ObjectInputStream s) throws java.io.IOException
  {
     String str = s.readUTF ();
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     org.omg.CORBA.Object obj = orb.string_to_object (str);
     org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate ();
     _set_delegate (delegate);
   } finally {
     orb.destroy() ;
   }
  }

  private void writeObject (java.io.ObjectOutputStream s) throws java.io.IOException
  {
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     String str = orb.object_to_string (this);
     s.writeUTF (str);
   } finally {
     orb.destroy() ;
   }
  }
} // class _EmsSession_IStub
